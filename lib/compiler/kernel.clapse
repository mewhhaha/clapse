module bootstrap_phase9_compiler_kernel
import compiler.parser
import compiler.prelude
import compiler.formatter
import compiler.json_response
import compiler.scan
import compiler.lsp_kernel
import host.clapse
export clapse_run

data CommandTag = CommandCompile | CommandFormat | CommandSelfhost
  | CommandLspSymbolIndex | CommandLspHover | CommandLspDefinition | CommandUnknown
data MonadicLine = MonadicLineNil
  | MonadicLineNode
    Int
    Int
    Int
    Int
    Int
    Int
    MonadicLine

data ParsedLine = ParsedLine MonadicLine Int
data ChainCollect = ChainCollect MonadicLine Int Int Int Int
data ClassMethodExpr = CBool bool | CVar i64 | CNot ClassMethodExpr | CAnd ClassMethodExpr ClassMethodExpr | COr ClassMethodExpr ClassMethodExpr
  | CId | CCompose ClassMethodExpr ClassMethodExpr | CMap ClassMethodExpr ClassMethodExpr
data ClassLawRule = LawComposeLeftIdentity | LawComposeRightIdentity | LawComposeAssociateRight | LawMapIdentity | LawMapFusion | LawBoolDoubleNot | LawBoolNotTrue | LawBoolNotFalse | LawBoolAndTrueLeft | LawBoolAndTrueRight | LawBoolAndFalseLeft | LawBoolAndFalseRight | LawBoolOrTrueLeft | LawBoolOrTrueRight | LawBoolOrFalseLeft | LawBoolOrFalseRight | LawBoolAndAbsorbLeft | LawBoolAndAbsorbRight | LawBoolOrAbsorbLeft | LawBoolOrAbsorbRight | LawBoolAndComplementLeft | LawBoolAndComplementRight | LawBoolAndComplementChainLeftLeft | LawBoolAndComplementChainLeftRight | LawBoolAndComplementChainRightLeft | LawBoolAndComplementChainRightRight | LawBoolOrComplementLeft | LawBoolOrComplementRight | LawBoolOrComplementChainLeftLeft | LawBoolOrComplementChainLeftRight | LawBoolOrComplementChainRightLeft | LawBoolOrComplementChainRightRight | LawBoolAndConsensusNotOrLeft | LawBoolAndConsensusNotOrRight | LawBoolAndConsensusOrNotLeft | LawBoolAndConsensusOrNotRight | LawBoolOrConsensusNotAndLeft | LawBoolOrConsensusNotAndRight | LawBoolOrConsensusAndNotLeft | LawBoolOrConsensusAndNotRight | LawBoolAndChainLeftLeft | LawBoolAndChainLeftRight | LawBoolAndChainRightLeft | LawBoolAndChainRightRight | LawBoolOrChainLeftLeft | LawBoolOrChainLeftRight | LawBoolOrChainRightLeft | LawBoolOrChainRightRight | LawBoolIdempotent
data ClassMethodExprType = ClassMethodExprTypeBool | ClassMethodExprTypeFunctor | ClassMethodExprTypeCompose | ClassMethodExprTypeUnknown
data ClassMethodExprEffect = ClassMethodExprEffectPure | ClassMethodExprEffectUnknown
data ClassMethodExprSignature = ClassMethodExprSignature ClassMethodExprType ClassMethodExprEffect
data ClassMethodExprSignatureFamily = ClassMethodExprSignatureFamilyBoolPure
  | ClassMethodExprSignatureFamilyComposePure
  | ClassMethodExprSignatureFamilyFunctorPure
  | ClassMethodExprSignatureFamilyOther
data ClassMethodExprDispatchKey = ClassMethodExprDispatchKey ClassMethodExprRootKind ClassMethodExprSignatureFamily
data ClassLawRuleList = ClassLawRuleListNil | ClassLawRuleListNode ClassLawRule ClassLawRuleList
data ClassMethodExprRootKind = ClassMethodExprRootKindNot | ClassMethodExprRootKindAnd | ClassMethodExprRootKindOr | ClassMethodExprRootKindCompose | ClassMethodExprRootKindMap | ClassMethodExprRootKindBool | ClassMethodExprRootKindVar | ClassMethodExprRootKindOther

kernel_class_dispatch = class_dispatch_static
class_dispatch_default_resolved =
  infer_class_dispatch kernel_class_dispatch ClassEvidenceResolved class_fundep_metadata_default

resolve_class_method dispatch static_method dynamic_method =
  case class_dispatch_mode dispatch of
    ClassDispatchStatic -> static_method
    ClassDispatchDynamic -> dynamic_method

rewrite_bool_law_expr expr =
  case expr of
    CBool b -> CBool b
    CVar _ -> expr
    CId -> CId
    CNot inner ->
      CNot (rewrite_bool_law_expr inner)
    CAnd left right =
      CAnd (rewrite_bool_law_expr left) (rewrite_bool_law_expr right)
    COr left right =
      COr (rewrite_bool_law_expr left) (rewrite_bool_law_expr right)
    CCompose left right ->
      CCompose (rewrite_bool_law_expr left) (rewrite_bool_law_expr right)
    CMap f xs ->
      CMap (rewrite_bool_law_expr f) (rewrite_bool_law_expr xs)

class_method_expr_type expr =
  case expr of
    CBool _ -> ClassMethodExprTypeBool
    CNot inner ->
      case class_method_expr_type inner of
        ClassMethodExprTypeBool -> ClassMethodExprTypeBool
        _ -> ClassMethodExprTypeUnknown
    CAnd left right ->
      case class_method_expr_type left of
        ClassMethodExprTypeBool ->
          case class_method_expr_type right of
            ClassMethodExprTypeBool -> ClassMethodExprTypeBool
            _ -> ClassMethodExprTypeUnknown
        _ -> ClassMethodExprTypeUnknown
    COr left right ->
      case class_method_expr_type left of
        ClassMethodExprTypeBool ->
          case class_method_expr_type right of
            ClassMethodExprTypeBool -> ClassMethodExprTypeBool
            _ -> ClassMethodExprTypeUnknown
        _ -> ClassMethodExprTypeUnknown
    CCompose _ _ -> ClassMethodExprTypeCompose
    CMap _ _ -> ClassMethodExprTypeFunctor
    CId -> ClassMethodExprTypeFunctor
    _ -> ClassMethodExprTypeUnknown

class_method_expr_effect expr =
  case expr of
    CBool _ -> ClassMethodExprEffectPure
    CId -> ClassMethodExprEffectPure
    CVar _ -> ClassMethodExprEffectPure
    CNot inner -> class_method_expr_effect inner
    CAnd left right ->
      case class_method_expr_effect left of
        ClassMethodExprEffectPure ->
          case class_method_expr_effect right of
            ClassMethodExprEffectPure -> ClassMethodExprEffectPure
            _ -> ClassMethodExprEffectUnknown
        _ -> ClassMethodExprEffectUnknown
    COr left right ->
      case class_method_expr_effect left of
        ClassMethodExprEffectPure ->
          case class_method_expr_effect right of
            ClassMethodExprEffectPure -> ClassMethodExprEffectPure
            _ -> ClassMethodExprEffectUnknown
        _ -> ClassMethodExprEffectUnknown
    CCompose left right ->
      case class_method_expr_effect left of
        ClassMethodExprEffectPure ->
          case class_method_expr_effect right of
            ClassMethodExprEffectPure -> ClassMethodExprEffectPure
            _ -> ClassMethodExprEffectUnknown
        _ -> ClassMethodExprEffectUnknown
    CMap f xs ->
      case class_method_expr_effect f of
        ClassMethodExprEffectPure ->
          case class_method_expr_effect xs of
            ClassMethodExprEffectPure -> ClassMethodExprEffectPure
            _ -> ClassMethodExprEffectUnknown
        _ -> ClassMethodExprEffectUnknown

class_method_expr_signature expr =
  ClassMethodExprSignature (class_method_expr_type expr) (class_method_expr_effect expr)

class_method_expr_signature_family signature =
  case signature of
    ClassMethodExprSignature ClassMethodExprTypeBool ClassMethodExprEffectPure ->
      ClassMethodExprSignatureFamilyBoolPure
    ClassMethodExprSignature ClassMethodExprTypeCompose ClassMethodExprEffectPure ->
      ClassMethodExprSignatureFamilyComposePure
    ClassMethodExprSignature ClassMethodExprTypeFunctor ClassMethodExprEffectPure ->
      ClassMethodExprSignatureFamilyFunctorPure
    _ -> ClassMethodExprSignatureFamilyOther

class_method_expr_dispatch_key root_kind signature =
  ClassMethodExprDispatchKey root_kind (class_method_expr_signature_family signature)

class_law_rules_for_dispatch_key key =
  case key of
    ClassMethodExprDispatchKey root_kind signature_family ->
      case root_kind of
        ClassMethodExprRootKindNot ->
          case signature_family of
            ClassMethodExprSignatureFamilyBoolPure -> class_law_rules_not
            _ -> class_law_rules_empty
        ClassMethodExprRootKindAnd ->
          case signature_family of
            ClassMethodExprSignatureFamilyBoolPure -> class_law_rules_and
            _ -> class_law_rules_empty
        ClassMethodExprRootKindOr ->
          case signature_family of
            ClassMethodExprSignatureFamilyBoolPure -> class_law_rules_or
            _ -> class_law_rules_empty
        ClassMethodExprRootKindCompose ->
          case signature_family of
            ClassMethodExprSignatureFamilyComposePure -> class_law_rules_compose
            _ -> class_law_rules_empty
        ClassMethodExprRootKindMap ->
          case signature_family of
            ClassMethodExprSignatureFamilyFunctorPure -> class_law_rules_map
            _ -> class_law_rules_empty
        ClassMethodExprRootKindBool ->
          class_law_rules_empty
        ClassMethodExprRootKindVar ->
          class_law_rules_empty
        ClassMethodExprRootKindOther ->
          class_law_rules_empty

class_law_dispatch_key_requires_strict_decrease dispatch_key =
  case dispatch_key of
    ClassMethodExprDispatchKey _ ClassMethodExprSignatureFamilyBoolPure -> true
    _ -> false

class_method_expr_signature_is_pure signature =
  case signature of
    ClassMethodExprSignature _ ClassMethodExprEffectPure -> true
    _ -> false

class_method_expr_is_pure expr =
  case class_method_expr_effect expr of
    ClassMethodExprEffectPure -> true
    _ -> false

class_method_expr_type_allows_compose expr_type =
  case expr_type of
    ClassMethodExprTypeBool -> false
    _ -> true

class_method_expr_type_allows_map expr_type =
  case expr_type of
    ClassMethodExprTypeBool -> false
    _ -> true

class_method_expr_compose_compatible expr =
  case expr of
    CCompose left right ->
      let left_type = class_method_expr_type left
          right_type = class_method_expr_type right
      in class_method_expr_type_allows_compose left_type && class_method_expr_type_allows_compose right_type
    _ -> false

class_method_expr_map_compatible expr =
  case expr of
    CMap f xs ->
      let f_type = class_method_expr_type f
          xs_type = class_method_expr_type xs
      in class_method_expr_type_allows_map f_type && class_method_expr_type_allows_map xs_type
    _ -> false

class_law_rules_empty = ClassLawRuleListNil

class_law_rules_compose =
  ClassLawRuleListNode LawComposeLeftIdentity
    (ClassLawRuleListNode LawComposeRightIdentity
      (ClassLawRuleListNode LawComposeAssociateRight ClassLawRuleListNil))

class_law_rules_map =
  ClassLawRuleListNode LawMapIdentity
    (ClassLawRuleListNode LawMapFusion ClassLawRuleListNil)

class_law_rules_not =
  ClassLawRuleListNode LawBoolDoubleNot
    (ClassLawRuleListNode LawBoolNotTrue
      (ClassLawRuleListNode LawBoolNotFalse ClassLawRuleListNil))

class_law_rules_and =
  ClassLawRuleListNode LawBoolAndTrueLeft
    (ClassLawRuleListNode LawBoolAndTrueRight
      (ClassLawRuleListNode LawBoolAndFalseLeft
        (ClassLawRuleListNode LawBoolAndFalseRight
          (ClassLawRuleListNode LawBoolAndAbsorbLeft
            (ClassLawRuleListNode LawBoolAndAbsorbRight
              (ClassLawRuleListNode LawBoolAndComplementLeft
                (ClassLawRuleListNode LawBoolAndComplementRight
                  (ClassLawRuleListNode LawBoolAndComplementChainLeftLeft
                    (ClassLawRuleListNode LawBoolAndComplementChainLeftRight
                      (ClassLawRuleListNode LawBoolAndComplementChainRightLeft
                        (ClassLawRuleListNode LawBoolAndComplementChainRightRight
                          (ClassLawRuleListNode LawBoolAndConsensusNotOrLeft
                            (ClassLawRuleListNode LawBoolAndConsensusNotOrRight
                              (ClassLawRuleListNode LawBoolAndConsensusOrNotLeft
                                (ClassLawRuleListNode LawBoolAndConsensusOrNotRight
                                        (ClassLawRuleListNode LawBoolAndChainLeftLeft
                                          (ClassLawRuleListNode LawBoolAndChainLeftRight
                                            (ClassLawRuleListNode LawBoolAndChainRightLeft
                                              (ClassLawRuleListNode LawBoolAndChainRightRight
                                                (ClassLawRuleListNode LawBoolIdempotent ClassLawRuleListNil)))))))))))))))))

class_law_rules_or =
  ClassLawRuleListNode LawBoolOrTrueLeft
    (ClassLawRuleListNode LawBoolOrTrueRight
      (ClassLawRuleListNode LawBoolOrFalseLeft
        (ClassLawRuleListNode LawBoolOrFalseRight
          (ClassLawRuleListNode LawBoolOrAbsorbLeft
            (ClassLawRuleListNode LawBoolOrAbsorbRight
              (ClassLawRuleListNode LawBoolOrComplementLeft
                (ClassLawRuleListNode LawBoolOrComplementRight
                  (ClassLawRuleListNode LawBoolOrComplementChainLeftLeft
                    (ClassLawRuleListNode LawBoolOrComplementChainLeftRight
                      (ClassLawRuleListNode LawBoolOrComplementChainRightLeft
                        (ClassLawRuleListNode LawBoolOrComplementChainRightRight
                          (ClassLawRuleListNode LawBoolOrConsensusNotAndLeft
                            (ClassLawRuleListNode LawBoolOrConsensusNotAndRight
                              (ClassLawRuleListNode LawBoolOrConsensusAndNotLeft
                                (ClassLawRuleListNode LawBoolOrConsensusAndNotRight
                                      (ClassLawRuleListNode LawBoolOrChainLeftLeft
                                        (ClassLawRuleListNode LawBoolOrChainLeftRight
                                          (ClassLawRuleListNode LawBoolOrChainRightLeft
                                            (ClassLawRuleListNode LawBoolOrChainRightRight
                                              (ClassLawRuleListNode LawBoolIdempotent ClassLawRuleListNil)))))))))))))))))

class_method_expr_root_kind expr =
  case expr of
    CNot _ -> ClassMethodExprRootKindNot
    CAnd _ _ -> ClassMethodExprRootKindAnd
    COr _ _ -> ClassMethodExprRootKindOr
    CCompose _ _ -> ClassMethodExprRootKindCompose
    CMap _ _ -> ClassMethodExprRootKindMap
    CBool _ -> ClassMethodExprRootKindBool
    CVar _ -> ClassMethodExprRootKindVar
    _ -> ClassMethodExprRootKindOther

class_method_expr_signature_is_bool_pure signature =
  case signature of
    ClassMethodExprSignature ClassMethodExprTypeBool ClassMethodExprEffectPure -> true
    _ -> false

class_method_expr_signature_is_compose_pure signature =
  case signature of
    ClassMethodExprSignature ClassMethodExprTypeCompose ClassMethodExprEffectPure -> true
    _ -> false

class_method_expr_signature_is_functor_pure signature =
  case signature of
    ClassMethodExprSignature ClassMethodExprTypeFunctor ClassMethodExprEffectPure -> true
    _ -> false

class_law_rules_full =
  ClassLawRuleListNode LawComposeLeftIdentity
    (ClassLawRuleListNode LawComposeRightIdentity
      (ClassLawRuleListNode LawComposeAssociateRight
        (ClassLawRuleListNode LawMapIdentity
          (ClassLawRuleListNode LawMapFusion
                (ClassLawRuleListNode LawBoolDoubleNot
                  (ClassLawRuleListNode LawBoolNotTrue
                    (ClassLawRuleListNode LawBoolNotFalse
                      (ClassLawRuleListNode LawBoolAndTrueLeft
                (ClassLawRuleListNode LawBoolAndTrueRight
                  (ClassLawRuleListNode LawBoolAndFalseLeft
                    (ClassLawRuleListNode LawBoolAndFalseRight
                      (ClassLawRuleListNode LawBoolOrTrueLeft
                        (ClassLawRuleListNode LawBoolOrTrueRight
                          (ClassLawRuleListNode LawBoolOrFalseLeft
                            (ClassLawRuleListNode LawBoolOrFalseRight
                              (ClassLawRuleListNode LawBoolAndAbsorbLeft
                                (ClassLawRuleListNode LawBoolAndAbsorbRight
                                  (ClassLawRuleListNode LawBoolOrAbsorbLeft
                                    (ClassLawRuleListNode LawBoolOrAbsorbRight
                                      (ClassLawRuleListNode LawBoolAndComplementLeft
                                        (ClassLawRuleListNode LawBoolAndComplementRight
                                          (ClassLawRuleListNode LawBoolAndComplementChainLeftLeft
                                            (ClassLawRuleListNode LawBoolAndComplementChainLeftRight
                                              (ClassLawRuleListNode LawBoolAndComplementChainRightLeft
                                                (ClassLawRuleListNode LawBoolAndComplementChainRightRight
                                                  (ClassLawRuleListNode LawBoolOrComplementLeft
                                                    (ClassLawRuleListNode LawBoolOrComplementRight
                                                      (ClassLawRuleListNode LawBoolOrComplementChainLeftLeft
                                                        (ClassLawRuleListNode LawBoolOrComplementChainLeftRight
                                                          (ClassLawRuleListNode LawBoolOrComplementChainRightLeft
                                                            (ClassLawRuleListNode LawBoolOrComplementChainRightRight
                                                              (ClassLawRuleListNode LawBoolAndConsensusNotOrLeft
                                                                (ClassLawRuleListNode LawBoolAndConsensusNotOrRight
                                                                  (ClassLawRuleListNode LawBoolAndConsensusOrNotLeft
                                                                    (ClassLawRuleListNode LawBoolAndConsensusOrNotRight
                                                                      (ClassLawRuleListNode LawBoolOrConsensusNotAndLeft
                                                                        (ClassLawRuleListNode LawBoolOrConsensusNotAndRight
                                                                          (ClassLawRuleListNode LawBoolOrConsensusAndNotLeft
                                                                            (ClassLawRuleListNode LawBoolOrConsensusAndNotRight
                                                                              (ClassLawRuleListNode LawBoolAndChainLeftLeft
                                                                                (ClassLawRuleListNode LawBoolAndChainLeftRight
                                                                                  (ClassLawRuleListNode LawBoolAndChainRightLeft
                                                                                    (ClassLawRuleListNode LawBoolAndChainRightRight
                                                                                      (ClassLawRuleListNode LawBoolOrChainLeftLeft
                                                                                        (ClassLawRuleListNode LawBoolOrChainLeftRight
                                                                                          (ClassLawRuleListNode LawBoolOrChainRightLeft
                                                                                            (ClassLawRuleListNode LawBoolOrChainRightRight
                                                                                              (ClassLawRuleListNode LawBoolIdempotent ClassLawRuleListNil)))))))))))))))))))))))))))

class_law_rule_guard_with_signature rule expr signature =
  let is_bool_pure =
    case signature of
      ClassMethodExprSignature ClassMethodExprTypeBool ClassMethodExprEffectPure -> true
      _ -> false
  let is_pure = class_method_expr_signature_is_pure signature
  in case rule of
    LawComposeLeftIdentity ->
      case expr of
        CCompose _ _ -> is_pure && class_method_expr_compose_compatible expr
        _ -> false
    LawComposeRightIdentity ->
      case expr of
        CCompose _ _ -> is_pure && class_method_expr_compose_compatible expr
        _ -> false
    LawComposeAssociateRight ->
      case signature of
        ClassMethodExprSignature ClassMethodExprTypeCompose ClassMethodExprEffectPure ->
          case expr of
            CCompose _ (CCompose _ _) -> true
            _ -> false
        _ -> false
    LawMapIdentity ->
      case expr of
        CMap _ _ -> is_pure && class_method_expr_map_compatible expr
        _ -> false
    LawMapFusion ->
      case expr of
        CMap _ _ -> is_pure && class_method_expr_map_compatible expr
        _ -> false
    LawBoolDoubleNot ->
      is_bool_pure &&
        case expr of
          CNot inner ->
            case inner of
              CNot _ -> true
              _ -> false
          _ -> false
    LawBoolNotTrue ->
      is_bool_pure &&
        case expr of
          CNot (CBool true) -> true
          _ -> false
    LawBoolNotFalse ->
      is_bool_pure &&
        case expr of
          CNot (CBool false) -> true
          _ -> false
    LawBoolAndTrueLeft ->
      is_bool_pure &&
        case expr of
          CAnd CBool true _ -> true
          _ -> false
    LawBoolAndTrueRight ->
      is_bool_pure &&
        case expr of
          CAnd _ CBool true -> true
          _ -> false
    LawBoolAndFalseLeft ->
      is_bool_pure &&
        case expr of
          CAnd CBool false _ -> true
          _ -> false
    LawBoolAndFalseRight ->
      is_bool_pure &&
        case expr of
          CAnd _ CBool false -> true
          _ -> false
    LawBoolOrTrueLeft ->
      is_bool_pure &&
        case expr of
          COr CBool true _ -> true
          _ -> false
    LawBoolOrTrueRight ->
      is_bool_pure &&
        case expr of
          COr _ CBool true -> true
          _ -> false
    LawBoolOrFalseLeft ->
      is_bool_pure &&
        case expr of
          COr CBool false _ -> true
          _ -> false
    LawBoolOrFalseRight ->
      is_bool_pure &&
        case expr of
          COr _ CBool false -> true
          _ -> false
    LawBoolAndAbsorbLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (COr y z) -> x == y || x == z
          _ -> false
    LawBoolAndAbsorbRight ->
      is_bool_pure &&
        case expr of
          CAnd (COr y z) x -> x == y || x == z
          _ -> false
    LawBoolOrAbsorbLeft ->
      is_bool_pure &&
        case expr of
          COr x (CAnd y z) -> x == y || x == z
          _ -> false
    LawBoolOrAbsorbRight ->
      is_bool_pure &&
        case expr of
          COr (CAnd y z) x -> x == y || x == z
          _ -> false
    LawBoolAndComplementLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (CNot y) -> x == y
          _ -> false
    LawBoolAndComplementRight ->
      is_bool_pure &&
        case expr of
          CAnd (CNot x) y -> x == y
          _ -> false
    LawBoolOrComplementLeft ->
      is_bool_pure &&
        case expr of
          COr x (CNot y) -> x == y
          _ -> false
    LawBoolOrComplementRight ->
      is_bool_pure &&
        case expr of
          COr (CNot x) y -> x == y
          _ -> false
    LawBoolAndComplementChainLeftLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (CAnd (CNot y) z) -> x == y
          _ -> false
    LawBoolAndComplementChainLeftRight ->
      is_bool_pure &&
        case expr of
          CAnd x (CAnd z (CNot y)) -> x == y
          _ -> false
    LawBoolAndComplementChainRightLeft ->
      is_bool_pure &&
        case expr of
          CAnd (CAnd (CNot y) z) x -> x == y
          _ -> false
    LawBoolAndComplementChainRightRight ->
      is_bool_pure &&
        case expr of
          CAnd (CAnd z (CNot y)) x -> x == y
          _ -> false
    LawBoolOrComplementChainLeftLeft ->
      is_bool_pure &&
        case expr of
          COr x (COr (CNot y) z) -> x == y
          _ -> false
    LawBoolOrComplementChainLeftRight ->
      is_bool_pure &&
        case expr of
          COr x (COr z (CNot y)) -> x == y
          _ -> false
    LawBoolOrComplementChainRightLeft ->
      is_bool_pure &&
        case expr of
          COr (COr (CNot y) z) x -> x == y
          _ -> false
    LawBoolOrComplementChainRightRight ->
      is_bool_pure &&
        case expr of
          COr (COr z (CNot y)) x -> x == y
          _ -> false
    LawBoolAndConsensusNotOrLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (COr (CNot y) z) -> x == y
          CAnd x (COr z (CNot y)) -> x == y
          _ -> false
    LawBoolAndConsensusNotOrRight ->
      is_bool_pure &&
        case expr of
          CAnd (COr (CNot y) z) x -> x == y
          CAnd (COr z (CNot y)) x -> x == y
          _ -> false
    LawBoolAndConsensusOrNotLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (COr y (CNot z)) -> x == z
          CAnd x (COr (CNot z) y) -> x == z
          _ -> false
    LawBoolAndConsensusOrNotRight ->
      is_bool_pure &&
        case expr of
          CAnd (COr y (CNot z)) x -> x == z
          CAnd (COr (CNot z) y) x -> x == z
          _ -> false
    LawBoolOrConsensusNotAndLeft ->
      is_bool_pure &&
        case expr of
          COr x (CAnd (CNot y) z) -> x == y
          COr x (CAnd z (CNot y)) -> x == y
          _ -> false
    LawBoolOrConsensusNotAndRight ->
      is_bool_pure &&
        case expr of
          COr (CAnd (CNot y) z) x -> x == y
          COr (CAnd z (CNot y)) x -> x == y
          _ -> false
    LawBoolOrConsensusAndNotLeft ->
      is_bool_pure &&
        case expr of
          COr x (CAnd y (CNot z)) -> x == z
          COr x (CAnd (CNot z) y) -> x == z
          _ -> false
    LawBoolOrConsensusAndNotRight ->
      is_bool_pure &&
        case expr of
          COr (CAnd y (CNot z)) x -> x == z
          COr (CAnd (CNot z) y) x -> x == z
          _ -> false
    LawBoolAndChainLeftLeft ->
      is_bool_pure &&
        case expr of
          CAnd x (CAnd x2 y) -> x == x2
          _ -> false
    LawBoolAndChainLeftRight ->
      is_bool_pure &&
        case expr of
          CAnd x (CAnd y x2) -> x == x2
          _ -> false
    LawBoolAndChainRightLeft ->
      is_bool_pure &&
        case expr of
          CAnd (CAnd x y) x2 -> x == x2
          _ -> false
    LawBoolAndChainRightRight ->
      is_bool_pure &&
        case expr of
          CAnd (CAnd y x) x2 -> x == x2
          _ -> false
    LawBoolOrChainLeftLeft ->
      is_bool_pure &&
        case expr of
          COr x (COr x2 y) -> x == x2
          _ -> false
    LawBoolOrChainLeftRight ->
      is_bool_pure &&
        case expr of
          COr x (COr y x2) -> x == x2
          _ -> false
    LawBoolOrChainRightLeft ->
      is_bool_pure &&
        case expr of
          COr (COr x y) x2 -> x == x2
          _ -> false
    LawBoolOrChainRightRight ->
      is_bool_pure &&
        case expr of
          COr (COr y x) x2 -> x == x2
          _ -> false
    LawBoolIdempotent ->
      is_bool_pure &&
        case expr of
          CAnd x y -> x == y
          COr x y -> x == y
          _ -> false

class_law_rule_guard rule expr =
  class_law_rule_guard_with_signature rule expr (class_method_expr_signature expr)

rewrite_class_law_rule rule expr =
  case rule of
    LawComposeLeftIdentity ->
      case expr of
        CCompose CId f -> f
        _ -> expr
    LawComposeRightIdentity ->
      case expr of
        CCompose f CId -> f
        _ -> expr
    LawComposeAssociateRight ->
      case expr of
        CCompose f (CCompose g h) -> CCompose (CCompose f g) h
        _ -> expr
    LawMapIdentity ->
      case expr of
        CMap CId xs -> xs
        _ -> expr
    LawMapFusion ->
      case expr of
        CMap f inner ->
          case inner of
            CMap g xs -> CMap (CCompose f g) xs
            _ -> expr
        _ -> expr
    LawBoolDoubleNot ->
      case expr of
        CNot inner ->
          case inner of
            CNot inner2 -> inner2
            _ -> expr
        _ -> expr
    LawBoolNotTrue ->
      case expr of
        CNot (CBool true) -> CBool false
        _ -> expr
    LawBoolNotFalse ->
      case expr of
        CNot (CBool false) -> CBool true
        _ -> expr
    LawBoolAndTrueLeft ->
      case expr of
        CAnd _ x -> x
        _ -> expr
    LawBoolAndTrueRight ->
      case expr of
        CAnd x _ -> x
        _ -> expr
    LawBoolAndFalseLeft ->
      case expr of
        CAnd _ _ -> CBool false
        _ -> expr
    LawBoolAndFalseRight ->
      case expr of
        CAnd _ _ -> CBool false
        _ -> expr
    LawBoolOrTrueLeft ->
      case expr of
        COr _ _ -> CBool true
        _ -> expr
    LawBoolOrTrueRight ->
      case expr of
        COr _ _ -> CBool true
        _ -> expr
    LawBoolOrFalseLeft ->
      case expr of
        COr _ x -> x
        _ -> expr
    LawBoolOrFalseRight ->
      case expr of
        COr x _ -> x
        _ -> expr
    LawBoolAndAbsorbLeft ->
      case expr of
        CAnd x (COr _ _) -> x
        _ -> expr
    LawBoolAndAbsorbRight ->
      case expr of
        CAnd (COr _ _) y -> y
        _ -> expr
    LawBoolOrAbsorbLeft ->
      case expr of
        COr x (CAnd _ _) -> x
        _ -> expr
    LawBoolOrAbsorbRight ->
      case expr of
        COr (CAnd _ _) y -> y
        _ -> expr
    LawBoolAndComplementLeft ->
      case expr of
        CAnd _ (CNot _) -> CBool false
        _ -> expr
    LawBoolAndComplementRight ->
      case expr of
        CAnd (CNot _) _ -> CBool false
        _ -> expr
    LawBoolAndConsensusNotOrLeft ->
      case expr of
        CAnd x (COr (CNot y) z) ->
          case x == y of
            true -> CAnd x z
            _ -> expr
        CAnd x (COr z (CNot y)) ->
          case x == y of
            true -> CAnd x z
            _ -> expr
        _ -> expr
    LawBoolAndConsensusNotOrRight ->
      case expr of
        CAnd (COr (CNot y) z) x ->
          case x == y of
            true -> CAnd x z
            _ -> expr
        CAnd (COr z (CNot y)) x ->
          case x == y of
            true -> CAnd x z
            _ -> expr
        _ -> expr
    LawBoolAndConsensusOrNotLeft ->
      case expr of
        CAnd x (COr y (CNot z)) ->
          case x == z of
            true -> CAnd x y
            _ -> expr
        CAnd x (COr (CNot z) y) ->
          case x == z of
            true -> CAnd x y
            _ -> expr
        _ -> expr
    LawBoolAndConsensusOrNotRight ->
      case expr of
        CAnd (COr y (CNot z)) x ->
          case x == z of
            true -> CAnd x y
            _ -> expr
        CAnd (COr (CNot z) y) x ->
          case x == z of
            true -> CAnd x y
            _ -> expr
        _ -> expr
    LawBoolOrComplementLeft ->
      case expr of
        COr _ (CNot _) -> CBool true
        _ -> expr
    LawBoolOrComplementRight ->
      case expr of
        COr (CNot _) _ -> CBool true
        _ -> expr
    LawBoolAndComplementChainLeftLeft ->
      case expr of
        CAnd x (CAnd (CNot x2) y) ->
          case x == x2 of
            true -> CBool false
            _ -> expr
        _ -> expr
    LawBoolAndComplementChainLeftRight ->
      case expr of
        CAnd x (CAnd y (CNot x2)) ->
          case x == x2 of
            true -> CBool false
            _ -> expr
        _ -> expr
    LawBoolAndComplementChainRightLeft ->
      case expr of
        CAnd (CAnd (CNot x2) y) x ->
          case x == x2 of
            true -> CBool false
            _ -> expr
        _ -> expr
    LawBoolAndComplementChainRightRight ->
      case expr of
        CAnd (CAnd y (CNot x2)) x ->
          case x == x2 of
            true -> CBool false
            _ -> expr
        _ -> expr
    LawBoolOrComplementChainLeftLeft ->
      case expr of
        COr x (COr (CNot x2) y) ->
          case x == x2 of
            true -> CBool true
            _ -> expr
        _ -> expr
    LawBoolOrComplementChainLeftRight ->
      case expr of
        COr x (COr y (CNot x2)) ->
          case x == x2 of
            true -> CBool true
            _ -> expr
        _ -> expr
    LawBoolOrComplementChainRightLeft ->
      case expr of
        COr (COr (CNot x2) y) x ->
          case x == x2 of
            true -> CBool true
            _ -> expr
        _ -> expr
    LawBoolOrComplementChainRightRight ->
      case expr of
        COr (COr y (CNot x2)) x ->
          case x == x2 of
            true -> CBool true
            _ -> expr
        _ -> expr
    LawBoolOrConsensusNotAndLeft ->
      case expr of
        COr x (CAnd (CNot y) z) ->
          case x == y of
            true -> COr x z
            _ -> expr
        COr x (CAnd z (CNot y)) ->
          case x == y of
            true -> COr x z
            _ -> expr
        _ -> expr
    LawBoolOrConsensusNotAndRight ->
      case expr of
        COr (CAnd (CNot y) z) x ->
          case x == y of
            true -> COr x z
            _ -> expr
        COr (CAnd z (CNot y)) x ->
          case x == y of
            true -> COr x z
            _ -> expr
        _ -> expr
    LawBoolOrConsensusAndNotLeft ->
      case expr of
        COr x (CAnd y (CNot z)) ->
          case x == z of
            true -> COr x y
            _ -> expr
        COr x (CAnd (CNot z) y) ->
          case x == z of
            true -> COr x y
            _ -> expr
        _ -> expr
    LawBoolOrConsensusAndNotRight ->
      case expr of
        COr (CAnd y (CNot z)) x ->
          case x == z of
            true -> COr x y
            _ -> expr
        COr (CAnd (CNot z) y) x ->
          case x == z of
            true -> COr x y
            _ -> expr
        _ -> expr
    LawBoolAndChainLeftLeft ->
      case expr of
        CAnd x (CAnd x2 y) -> CAnd x y
        _ -> expr
    LawBoolAndChainLeftRight ->
      case expr of
        CAnd x (CAnd y x2) -> CAnd x y
        _ -> expr
    LawBoolAndChainRightLeft ->
      case expr of
        CAnd (CAnd x y) x2 -> CAnd x y
        _ -> expr
    LawBoolAndChainRightRight ->
      case expr of
        CAnd (CAnd y x2) x -> CAnd y x
        _ -> expr
    LawBoolOrChainLeftLeft ->
      case expr of
        COr x (COr x2 y) -> COr x y
        _ -> expr
    LawBoolOrChainLeftRight ->
      case expr of
        COr x (COr y x2) -> COr x y
        _ -> expr
    LawBoolOrChainRightLeft ->
      case expr of
        COr (COr x y) x2 -> COr x y
        _ -> expr
    LawBoolOrChainRightRight ->
      case expr of
        COr (COr y x2) x -> COr y x
        _ -> expr
    LawBoolIdempotent ->
      case expr of
        CAnd x y ->
          case x == y of
            true -> x
            _ -> expr
        COr x y ->
          case x == y of
            true -> x
            _ -> expr
        _ -> expr

rewrite_class_law_rule_with_signature rule expr signature =
  case class_law_rule_guard_with_signature rule expr signature of
    false -> expr
    true -> rewrite_class_law_rule rule expr

apply_class_law_rule_once_with_signature rule expr signature before_cost strict_decrease =
  let candidate =
        case class_law_rule_guard_with_signature rule expr signature of
          true -> rewrite_class_law_rule_with_signature rule expr signature
          _ -> expr
      candidate_cost = class_method_expr_cost candidate
      cost_ok = class_law_expr_cost_ok expr candidate
      strict_ok =
        case strict_decrease of
          true -> candidate_cost < before_cost
          _ -> true
  in case cost_ok && strict_ok of
    true -> candidate
    _ -> expr

rewrite_class_law_rules_once_list rules dispatch_key expr signature before_cost strict_decrease =
  case rules of
    ClassLawRuleListNil -> expr
    ClassLawRuleListNode rule rest ->
      let expr1 = apply_class_law_rule_once_with_signature rule expr signature before_cost strict_decrease
      in case (expr1 == expr) of
        true ->
          let strict_decrease1 = class_law_dispatch_key_requires_strict_decrease dispatch_key
          in rewrite_class_law_rules_once_list rest dispatch_key expr1 signature before_cost strict_decrease1
        _ ->
          let signature1 = class_method_expr_signature expr1
          in
          let root_kind1 = class_method_expr_root_kind expr1
          in
          let dispatch_key1 = class_method_expr_dispatch_key root_kind1 signature1
          in
          let before_cost1 = class_method_expr_cost expr1
          in let strict_decrease1 = class_law_dispatch_key_requires_strict_decrease dispatch_key1
      in case (dispatch_key1 == dispatch_key) of
        true -> rewrite_class_law_rules_once_list rest dispatch_key1 expr1 signature1 before_cost1 strict_decrease1
        _ -> rewrite_class_law_rules_once_list
              (class_law_rules_for_dispatch_key dispatch_key1)
              dispatch_key1
              expr1
              signature1
              before_cost1
              strict_decrease1

rewrite_class_law_expr_once expr =
  let expr1 = rewrite_bool_law_expr expr
      signature1 = class_method_expr_signature expr1
      dispatch_key1 = class_method_expr_dispatch_key (class_method_expr_root_kind expr1) signature1
      before_cost1 = class_method_expr_cost expr1
      strict_decrease1 = class_law_dispatch_key_requires_strict_decrease dispatch_key1
  in rewrite_class_law_rules_once_list
    (class_law_rules_for_dispatch_key dispatch_key1)
    dispatch_key1
    expr1
    signature1
    before_cost1
    strict_decrease1

class_law_rewrite_stages = 4

class_method_expr_cost expr =
  case expr of
    CBool _ -> 1
    CVar _ -> 1
    CId -> 1
    CNot inner -> 1 + class_method_expr_cost inner
    CAnd left right -> 1 + class_method_expr_cost left + class_method_expr_cost right
    COr left right -> 1 + class_method_expr_cost left + class_method_expr_cost right
    CCompose left right -> 1 + class_method_expr_cost left + class_method_expr_cost right
    CMap f xs -> 1 + class_method_expr_cost f + class_method_expr_cost xs

class_law_expr_has_map_fusion_candidate expr =
  case expr of
    CMap _ inner ->
      case inner of
        CMap _ _ -> true
        _ -> class_law_expr_has_map_fusion_candidate inner
    CNot inner -> class_law_expr_has_map_fusion_candidate inner
    CAnd left right -> class_law_expr_has_map_fusion_candidate left || class_law_expr_has_map_fusion_candidate right
    COr left right -> class_law_expr_has_map_fusion_candidate left || class_law_expr_has_map_fusion_candidate right
    CCompose left right -> class_law_expr_has_map_fusion_candidate left || class_law_expr_has_map_fusion_candidate right
    _ -> false

class_law_expr_cost_growth_budget expr =
  case class_law_expr_has_map_fusion_candidate expr of
    true -> 1
    _ -> 0

class_law_expr_cost_ok expr expr1 =
  let cost0 = class_method_expr_cost expr
      cost1 = class_method_expr_cost expr1
      budget = class_law_expr_cost_growth_budget expr
  in cost1 <= (cost0 + budget)

rewrite_class_law_expr_fixedpoint_stages remaining expr =
  case remaining of
    0 -> expr
    _ ->
      let expr1 = rewrite_class_law_expr_once expr
      in case (expr1 == expr) of
        true -> expr1
        _ ->
          case class_law_expr_cost_ok expr expr1 of
            true -> rewrite_class_law_expr_fixedpoint_stages (remaining - 1) expr1
            _ -> expr

apply_class_law_rewrites dispatch law_expr =
  case class_dispatch_mode dispatch of
    ClassDispatchStatic -> rewrite_class_law_expr_fixedpoint_stages class_law_rewrite_stages law_expr
    ClassDispatchDynamic -> law_expr

derive_class_method_with_dispatch dispatch static_expr dynamic_expr =
  let selected_method = resolve_class_method dispatch static_expr dynamic_expr
  in apply_class_law_rewrites dispatch selected_method

derive_class_method static_expr dynamic_expr =
  derive_class_method_with_dispatch class_dispatch_default_resolved static_expr dynamic_expr

derive_law_expr_with_dispatch dispatch law_expr =
  apply_class_law_rewrites dispatch law_expr

derive_law_expr law_expr =
  derive_law_expr_with_dispatch class_dispatch_default_resolved law_expr

derive_instance_method_with_dispatch dispatch static_expr dynamic_expr =
  let selected_method = resolve_class_method dispatch static_expr dynamic_expr
  in apply_class_law_rewrites dispatch selected_method

derive_instance_method static_expr dynamic_expr =
  derive_instance_method_with_dispatch class_dispatch_default_resolved static_expr dynamic_expr

class_rewrite_pipeline dispatch static_expr dynamic_expr =
  derive_class_method_with_dispatch dispatch static_expr dynamic_expr

class_rewrite_pipeline_default evidence static_expr dynamic_expr =
  let dispatch = infer_class_dispatch kernel_class_dispatch evidence class_fundep_metadata_default
  in class_rewrite_pipeline dispatch static_expr dynamic_expr

class_rewrite_pipeline_applicative evidence_a evidence_b fundep_info static_expr dynamic_expr =
  let dispatch = infer_class_dispatch_applicative kernel_class_dispatch evidence_a evidence_b fundep_info
  in class_rewrite_pipeline dispatch static_expr dynamic_expr

class_rewrite_pipeline_static static_expr dynamic_expr =
  class_rewrite_pipeline kernel_class_dispatch static_expr dynamic_expr

data EscapeLifetimeAnnotation = EscapeLifetimeLocal | EscapeLifetimeEscaped | EscapeLifetimeUnknown
data OwnershipRewriteMode = OwnershipRewriteLinear | OwnershipRewriteCopyOnWrite
data SliceWriteAliasClass = SliceWriteAliasSingleUse | SliceWriteAliasSharedOrEscaped | SliceWriteAliasUnknown
data SliceSetU8WriteChainContext = SliceSetU8WriteChainContext EscapeLifetimeAnnotation SliceWriteAliasClass bool
data SliceSetU8WriteChainHint = SliceSetU8WriteChainHint
  EscapeLifetimeAnnotation
  SliceWriteAliasClass
  bool
data CollapseMemoryPass = MemoryPassEscapeLifetimeAnnotation | MemoryPassSliceOwnershipRewrite

-- collapse_pipeline order is explicit and intentionally staged.
collapse_pipeline_stages = 2

collapse_pipeline_escape_lifetime request_handle =
  -- Stage 1: explicit escape/lifetime annotation for write-chain classification.
  -- Current body is request-pure and deterministic; only metadata signals are derived.
  let _ = slice_set_u8_request_chain_hint request_handle
  in request_handle

collapse_pipeline_slice_ownership_rewrite request_handle =
  -- Stage 2: explicit ownership/COW selection for write-chain style.
  -- Stage body is currently request-pure: derive annotations, preserve request handle.
  let _ = slice_set_u8_request_chain_hint request_handle
  in request_handle

collapse_pipeline_slice_ownership_mode request_handle =
  collapse_pipeline_slice_write_policy request_handle

slice_set_u8_has_literal request_handle needle =
  let hay_len = slice_len request_handle
      needle_len = slice_len needle
      at = find_literal_start request_handle 0 hay_len needle needle_len
  in not (at == hay_len)

slice_set_u8_request_scope request_handle =
  let SliceSetU8WriteChainHint scope _ _ = slice_set_u8_request_chain_hint request_handle
  in scope

slice_set_u8_request_chain_hint request_handle =
  let has_slice_set_u8 = slice_set_u8_has_literal request_handle (str_to_slice "slice_set_u8")
      has_output_escape = slice_set_u8_has_literal request_handle (str_to_slice "\"output\"")
      has_return_escape = slice_set_u8_has_literal request_handle (str_to_slice "\"return\"")
      has_alias_hint = slice_set_u8_has_literal request_handle (str_to_slice ".asSlice")
  in case has_slice_set_u8 of
    true ->
      let escaped = has_output_escape || has_return_escape
          alias_class =
            case has_alias_hint of
              true -> SliceWriteAliasSharedOrEscaped
              _ -> SliceWriteAliasSingleUse
      in case escaped of
        true -> SliceSetU8WriteChainHint EscapeLifetimeEscaped alias_class true
        _ -> SliceSetU8WriteChainHint EscapeLifetimeLocal alias_class true
    _ -> SliceSetU8WriteChainHint EscapeLifetimeUnknown SliceWriteAliasUnknown false

slice_set_u8_chain_hint_to_context request_handle =
  let SliceSetU8WriteChainHint lifetime alias_hint _ =
        slice_set_u8_request_chain_hint request_handle
      base_out_of_bounds = false
  in SliceSetU8WriteChainContext lifetime alias_hint base_out_of_bounds

slice_set_u8_chain_policy request_handle =
  let request_hint = slice_set_u8_request_chain_hint request_handle
  in case request_hint of
    SliceSetU8WriteChainHint EscapeLifetimeLocal SliceWriteAliasSingleUse true -> OwnershipRewriteLinear
    SliceSetU8WriteChainHint EscapeLifetimeLocal SliceWriteAliasUnknown _ -> OwnershipRewriteCopyOnWrite
    SliceSetU8WriteChainHint EscapeLifetimeEscaped _ _ -> OwnershipRewriteCopyOnWrite
    SliceSetU8WriteChainHint _ SliceWriteAliasSharedOrEscaped _ -> OwnershipRewriteCopyOnWrite
    SliceSetU8WriteChainHint EscapeLifetimeUnknown _ _ -> OwnershipRewriteCopyOnWrite
    _ -> OwnershipRewriteCopyOnWrite

collapse_pipeline_slice_write_policy request_handle = slice_set_u8_chain_policy request_handle

slice_set_u8_base_context target start value ownership_mode =
  let target_len = slice_len target
      in_bounds = ((start >= 0) && (start < target_len))
      base_lifetime = case ownership_mode of
        OwnershipRewriteCopyOnWrite -> EscapeLifetimeEscaped
        _ ->
          case in_bounds of
            true -> EscapeLifetimeLocal
            _ -> EscapeLifetimeUnknown
  in SliceSetU8WriteChainContext base_lifetime SliceWriteAliasUnknown (not in_bounds)

slice_set_u8_context_with_alias target start value context =
  case context of
    SliceSetU8WriteChainContext lifetime alias_class out_of_bounds =
      let value_targets_ptr = value == slice_data_ptr target
          alias =
            case alias_class of
              SliceWriteAliasSharedOrEscaped -> SliceWriteAliasSharedOrEscaped
              SliceWriteAliasUnknown -> SliceWriteAliasUnknown
              _ ->
                case value_targets_ptr of
                  true -> SliceWriteAliasSharedOrEscaped
                  _ -> SliceWriteAliasSingleUse
      in SliceSetU8WriteChainContext lifetime alias out_of_bounds

slice_set_u8_context_with_freeze target start value context =
  case context of
    SliceSetU8WriteChainContext lifetime alias_class out_of_bounds ->
      let frozen_by_value = start == 0 && value == 0
      in SliceSetU8WriteChainContext lifetime alias_class (out_of_bounds || frozen_by_value)

slice_set_u8_rewrite_mode target start value context =
  case context of
    SliceSetU8WriteChainContext EscapeLifetimeLocal SliceWriteAliasSingleUse false -> OwnershipRewriteLinear
    _ -> OwnershipRewriteCopyOnWrite

slice_set_u8_context_mode target start value ownership_mode request_handle =
  let SliceSetU8WriteChainHint hint_lifetime hint_alias has_chain =
        slice_set_u8_request_chain_hint request_handle
      base_context = slice_set_u8_base_context target start value ownership_mode
      chain_scoped_context =
        case has_chain of
          true -> base_context
          _ ->
            let base_lifetime =
                  case base_context of
                    SliceSetU8WriteChainContext lifetime _ _ -> lifetime
                    _ -> EscapeLifetimeUnknown
                base_out_of_bounds =
                  case base_context of
                    SliceSetU8WriteChainContext _ _ out_of_bounds -> out_of_bounds
                    _ -> true
            in SliceSetU8WriteChainContext base_lifetime SliceWriteAliasSingleUse base_out_of_bounds
      scoped_lifetime =
        case has_chain of
          true ->
            case hint_lifetime of
              EscapeLifetimeEscaped -> EscapeLifetimeEscaped
              _ ->
                case chain_scoped_context of
                  SliceSetU8WriteChainContext base_lifetime _ _ -> base_lifetime
          _ ->
            case chain_scoped_context of
              SliceSetU8WriteChainContext base_lifetime _ _ -> base_lifetime
      merged_context =
        case hint_alias of
          SliceWriteAliasSingleUse ->
            SliceSetU8WriteChainContext scoped_lifetime SliceWriteAliasSingleUse
              (case chain_scoped_context of
                SliceSetU8WriteChainContext _ _ out_of_bounds -> out_of_bounds)
          SliceWriteAliasSharedOrEscaped ->
            SliceSetU8WriteChainContext EscapeLifetimeEscaped SliceWriteAliasSharedOrEscaped
              (case chain_scoped_context of
                SliceSetU8WriteChainContext _ _ out_of_bounds -> out_of_bounds)
          _ ->
            SliceSetU8WriteChainContext scoped_lifetime
              (case chain_scoped_context of
                SliceSetU8WriteChainContext _ alias_class _ -> alias_class)
              (case chain_scoped_context of
                SliceSetU8WriteChainContext _ _ out_of_bounds -> out_of_bounds)
  in slice_set_u8_context_with_freeze target start value (slice_set_u8_context_with_alias target start value merged_context)

slice_set_u8_context_mode_with_policy target start value ownership_mode request_handle =
  let context = slice_set_u8_context_mode target start value ownership_mode request_handle
  in slice_set_u8_rewrite_mode target start value context

collapse_pipeline_run request_handle =
  let with_annotations = collapse_pipeline_escape_lifetime request_handle
      with_ownership = collapse_pipeline_slice_ownership_rewrite with_annotations
  in with_ownership

slice_set_u8_write request_handle ownership_mode target start value =
  slice_set_u8_rewrite request_handle target start value ownership_mode

copy_slice_segment request_handle ownership_mode src src_start dst dst_start seg_len i = case (i == seg_len) of
  true -> dst
  _ ->
    case (i + 16 <= seg_len) of
      true ->
        let b0 = slice_get_u8 src (src_start + i)
            d0 = slice_set_u8_write request_handle ownership_mode dst (dst_start + i) b0
            b1 = slice_get_u8 src (src_start + i + 1)
            d1 = slice_set_u8_write request_handle ownership_mode d0 (dst_start + i + 1) b1
            b2 = slice_get_u8 src (src_start + i + 2)
            d2 = slice_set_u8_write request_handle ownership_mode d1 (dst_start + i + 2) b2
            b3 = slice_get_u8 src (src_start + i + 3)
            d3 = slice_set_u8_write request_handle ownership_mode d2 (dst_start + i + 3) b3
            b4 = slice_get_u8 src (src_start + i + 4)
            d4 = slice_set_u8_write request_handle ownership_mode d3 (dst_start + i + 4) b4
            b5 = slice_get_u8 src (src_start + i + 5)
            d5 = slice_set_u8_write request_handle ownership_mode d4 (dst_start + i + 5) b5
            b6 = slice_get_u8 src (src_start + i + 6)
            d6 = slice_set_u8_write request_handle ownership_mode d5 (dst_start + i + 6) b6
            b7 = slice_get_u8 src (src_start + i + 7)
            d7 = slice_set_u8_write request_handle ownership_mode d6 (dst_start + i + 7) b7
            b8 = slice_get_u8 src (src_start + i + 8)
            d8 = slice_set_u8_write request_handle ownership_mode d7 (dst_start + i + 8) b8
            b9 = slice_get_u8 src (src_start + i + 9)
            d9 = slice_set_u8_write request_handle ownership_mode d8 (dst_start + i + 9) b9
            b10 = slice_get_u8 src (src_start + i + 10)
            d10 = slice_set_u8_write request_handle ownership_mode d9 (dst_start + i + 10) b10
            b11 = slice_get_u8 src (src_start + i + 11)
            d11 = slice_set_u8_write request_handle ownership_mode d10 (dst_start + i + 11) b11
            b12 = slice_get_u8 src (src_start + i + 12)
            d12 = slice_set_u8_write request_handle ownership_mode d11 (dst_start + i + 12) b12
            b13 = slice_get_u8 src (src_start + i + 13)
            d13 = slice_set_u8_write request_handle ownership_mode d12 (dst_start + i + 13) b13
            b14 = slice_get_u8 src (src_start + i + 14)
            d14 = slice_set_u8_write request_handle ownership_mode d13 (dst_start + i + 14) b14
            b15 = slice_get_u8 src (src_start + i + 15)
            d15 = slice_set_u8_write request_handle ownership_mode d14 (dst_start + i + 15) b15
        in copy_slice_segment request_handle ownership_mode src src_start d15 dst_start seg_len (i + 16)
      _ ->
        let b = slice_get_u8 src (src_start + i)
            next = slice_set_u8_write request_handle ownership_mode dst (dst_start + i) b
        in copy_slice_segment request_handle ownership_mode src src_start next dst_start seg_len (i + 1)

-- Existing helper: copy-on-write path (reuses existing slice copy/set behavior).
slice_set_u8_cow request_handle ownership_mode target start value =
  let target_len = slice_len target
      copied = slice_new_u8 target_len
      copied1 = copy_slice_segment request_handle OwnershipRewriteLinear target 0 copied 0 target_len 0
      copied2 = slice_set_u8_write request_handle OwnershipRewriteLinear copied1 start value
  in copied2

slice_set_u8_rewrite request_handle target start value ownership_mode =
  let inferred_mode = slice_set_u8_context_mode_with_policy target start value ownership_mode request_handle
  in case inferred_mode of
    OwnershipRewriteCopyOnWrite -> slice_set_u8_cow request_handle ownership_mode target start value
    _ -> slice_set_u8 target start value

min2 a b = case (a > b) of
  true -> b
  _ -> a

matches_literal_at request_handle start lit j lit_len = case (j == lit_len) of
  true -> true
  _ ->
    let req_byte = slice_get_u8 request_handle (start + j)
        key_byte = slice_get_u8 lit j
    in case (req_byte == key_byte) of
      true -> matches_literal_at request_handle start lit (j + 1) lit_len
      _ -> false

find_literal_start request_handle i req_len lit lit_len = case (i + lit_len <= req_len) of
  true -> find_literal_start_step request_handle i req_len lit lit_len
  _ -> req_len

find_literal_start_step request_handle i req_len lit lit_len =
  case (matches_literal_at request_handle i lit 0 lit_len) of
    true -> i
    _ -> find_literal_start request_handle (i + 1) req_len lit lit_len

is_compile_mode_literal request_handle mode_start req_len mode_txt =
  let lit = str_to_slice mode_txt
      lit_len = slice_len lit
      in_bounds = mode_start + lit_len < req_len
  in case in_bounds of
    true -> is_compile_mode_literal_match request_handle mode_start lit lit_len
    _ -> false

is_compile_mode_literal_match request_handle mode_start lit lit_len =
  case (matches_literal_at request_handle mode_start lit 0 lit_len) of
    true -> (slice_get_u8 request_handle (mode_start + lit_len) == 34)
    _ -> false

is_command_literal request_handle start req_len lit_txt =
  is_compile_mode_literal request_handle start req_len lit_txt

parse_command_tag request_handle value_start req_len command tag =
  case is_command_literal request_handle value_start req_len command of
    true -> Just tag
    _ -> Nothing

command_tag_at request_handle value_start req_len =
  case parse_command_tag request_handle value_start req_len "compile" CommandCompile of
    Just tag -> Just tag
    _ ->
      case parse_command_tag request_handle value_start req_len "format" CommandFormat of
        Just tag -> Just tag
        _ ->
          case parse_command_tag request_handle value_start req_len "selfhost-artifacts" CommandSelfhost of
            Just tag -> Just tag
            _ ->
              case parse_command_tag request_handle value_start req_len "lsp-symbol-index" CommandLspSymbolIndex of
                Just tag -> Just tag
                _ ->
                  case parse_command_tag request_handle value_start req_len "lsp-hover" CommandLspHover of
                    Just tag -> Just tag
                    _ -> parse_command_tag request_handle value_start req_len "lsp-definition" CommandLspDefinition

find_command_tag request_handle i req_len =
  let value_start = scan_find_json_key_value_start request_handle i req_len "\"command\""
      maybe_start =
        case (value_start == req_len) of
          true -> Nothing
          _ -> Just value_start
  in maybe_bind maybe_start (\start -> command_tag_at request_handle start req_len)

command_tag request_handle =
  let req_len = slice_len request_handle
      scan_limit = 256
      scan_len = min2 req_len scan_limit
      raw_tag = find_command_tag request_handle 0 scan_len
  in maybe_with_default CommandUnknown raw_tag

clapse_run request_handle =
  let tagged_request = collapse_pipeline_run request_handle
      ownership_mode = collapse_pipeline_slice_ownership_mode tagged_request
      tag = command_tag tagged_request
  in case tag of
    CommandCompile -> compile_response tagged_request ownership_mode
    CommandFormat -> format_ok_response tagged_request ownership_mode
    CommandSelfhost -> selfhost_ok_response tagged_request ownership_mode
    CommandLspSymbolIndex -> lsp_symbol_index_response tagged_request ownership_mode (slice_len tagged_request)
    CommandLspHover -> lsp_hover_response tagged_request ownership_mode (slice_len tagged_request)
    CommandLspDefinition -> lsp_definition_response tagged_request ownership_mode (slice_len tagged_request)
    CommandUnknown -> unknown_error_response tagged_request ownership_mode
