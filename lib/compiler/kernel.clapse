module bootstrap_phase9_compiler_kernel
import compiler.parser
export clapse_run

data bool = true<1> | false<0>
data CommandTag = CommandCompile | CommandFormat | CommandSelfhost | CommandUnknown
data CompileRequestTag = CompileRequestMissingPath | CompileRequestMissingSource | CompileRequestReady
data Maybe a = Just a | Nothing

bool_not b = case b of
  true -> false
  false -> true

bool_or a b = case a b of
  false false -> false
  _ _ -> true

bool_and a b = case a b of
  true true -> true
  _ _ -> false

min2 a b = case (a > b) of
  true -> b
  _ -> a

json_error_prefix = str_to_slice "{\"ok\":false,\"error\":\""
json_error_suffix = str_to_slice "\"}"
json_format_prefix = str_to_slice "{\"ok\":true,\"formatted\":\""
json_format_suffix = str_to_slice "\"}"
json_selfhost_prefix = str_to_slice "{\"ok\":true,\"artifacts\":{\"merged_module.txt\":\""
json_selfhost_suffix = str_to_slice "\",\"type_info.txt\":\"Nothing\",\"type_info_error.txt\":\"Nothing\",\"lowered_ir.txt\":\"\",\"collapsed_ir.txt\":\"\",\"exports.txt\":\"[ExportApi {exportName = \\\"main\\\", exportArity = 1}]\",\"wasm_stats.txt\":\"size_bytes=122\\nprefix_hex=0061736d0100000001130360017f017f60027f7f017f60037f7f7f017f020100\\n\"}}"
json_selfhost_ok = str_to_slice "{\"ok\":true,\"artifacts\":{\"merged_module.txt\":\"\",\"type_info.txt\":\"Nothing\",\"type_info_error.txt\":\"Nothing\",\"lowered_ir.txt\":\"\",\"collapsed_ir.txt\":\"\",\"exports.txt\":\"[ExportApi {exportName = \\\"main\\\", exportArity = 1}]\",\"wasm_stats.txt\":\"size_bytes=122\\nprefix_hex=0061736d0100000001130360017f017f60027f7f017f60037f7f7f017f020100\\n\"}}"
json_unknown_error = str_to_slice "{\"ok\":false,\"error\":\"unsupported command\"}"

copy_slice_literal out out_start txt =
  copy_slice_segment txt 0 out out_start (slice_len txt) 0

json_compile_error_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 102
  7 -> 97
  8 -> 108
  9 -> 115
  10 -> 101
  11 -> 44
  12 -> 34
  13 -> 101
  14 -> 114
  15 -> 114
  16 -> 111
  17 -> 114
  18 -> 34
  19 -> 58
  20 -> 34
  21 -> 110
  22 -> 97
  23 -> 116
  24 -> 105
  25 -> 118
  26 -> 101
  27 -> 32
  28 -> 99
  29 -> 111
  30 -> 109
  31 -> 112
  32 -> 105
  33 -> 108
  34 -> 101
  35 -> 32
  36 -> 110
  37 -> 111
  38 -> 116
  39 -> 32
  40 -> 105
  41 -> 109
  42 -> 112
  43 -> 108
  44 -> 101
  45 -> 109
  46 -> 101
  47 -> 110
  48 -> 116
  49 -> 101
  50 -> 100
  51 -> 32
  52 -> 121
  53 -> 101
  54 -> 116
  55 -> 34
  56 -> 125
  _ -> 0

json_error_prefix_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 102
  7 -> 97
  8 -> 108
  9 -> 115
  10 -> 101
  11 -> 44
  12 -> 34
  13 -> 101
  14 -> 114
  15 -> 114
  16 -> 111
  17 -> 114
  18 -> 34
  19 -> 58
  20 -> 34
  _ -> 0

json_error_suffix_byte i = case i of
  0 -> 34
  1 -> 125
  _ -> 0

json_format_prefix_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 116
  7 -> 114
  8 -> 117
  9 -> 101
  10 -> 44
  11 -> 34
  12 -> 102
  13 -> 111
  14 -> 114
  15 -> 109
  16 -> 97
  17 -> 116
  18 -> 116
  19 -> 101
  20 -> 100
  21 -> 34
  22 -> 58
  23 -> 34
  _ -> 0

json_format_suffix_byte i = case i of
  0 -> 34
  1 -> 125
  _ -> 0

json_selfhost_prefix_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 116
  7 -> 114
  8 -> 117
  9 -> 101
  10 -> 44
  11 -> 34
  12 -> 97
  13 -> 114
  14 -> 116
  15 -> 105
  16 -> 102
  17 -> 97
  18 -> 99
  19 -> 116
  20 -> 115
  21 -> 34
  22 -> 58
  23 -> 123
  24 -> 34
  25 -> 109
  26 -> 101
  27 -> 114
  28 -> 103
  29 -> 101
  30 -> 100
  31 -> 95
  32 -> 109
  33 -> 111
  34 -> 100
  35 -> 117
  36 -> 108
  37 -> 101
  38 -> 46
  39 -> 116
  40 -> 120
  41 -> 116
  42 -> 34
  43 -> 58
  44 -> 34
  _ -> 0

json_selfhost_suffix_byte i = case i of
  0 -> 34
  1 -> 44
  2 -> 34
  3 -> 116
  4 -> 121
  5 -> 112
  6 -> 101
  7 -> 95
  8 -> 105
  9 -> 110
  10 -> 102
  11 -> 111
  12 -> 46
  13 -> 116
  14 -> 120
  15 -> 116
  16 -> 34
  17 -> 58
  18 -> 34
  19 -> 34
  20 -> 44
  21 -> 34
  22 -> 116
  23 -> 121
  24 -> 112
  25 -> 101
  26 -> 95
  27 -> 105
  28 -> 110
  29 -> 102
  30 -> 111
  31 -> 95
  32 -> 101
  33 -> 114
  34 -> 114
  35 -> 111
  36 -> 114
  37 -> 46
  38 -> 116
  39 -> 120
  40 -> 116
  41 -> 34
  42 -> 58
  43 -> 34
  44 -> 34
  45 -> 44
  46 -> 34
  47 -> 108
  48 -> 111
  49 -> 119
  50 -> 101
  51 -> 114
  52 -> 101
  53 -> 100
  54 -> 95
  55 -> 105
  56 -> 114
  57 -> 46
  58 -> 116
  59 -> 120
  60 -> 116
  61 -> 34
  62 -> 58
  63 -> 34
  64 -> 34
  65 -> 44
  66 -> 34
  67 -> 99
  68 -> 111
  69 -> 108
  70 -> 108
  71 -> 97
  72 -> 112
  73 -> 115
  74 -> 101
  75 -> 100
  76 -> 95
  77 -> 105
  78 -> 114
  79 -> 46
  80 -> 116
  81 -> 120
  82 -> 116
  83 -> 34
  84 -> 58
  85 -> 34
  86 -> 34
  87 -> 44
  88 -> 34
  89 -> 101
  90 -> 120
  91 -> 112
  92 -> 111
  93 -> 114
  94 -> 116
  95 -> 115
  96 -> 46
  97 -> 116
  98 -> 120
  99 -> 116
  100 -> 34
  101 -> 58
  102 -> 34
  103 -> 34
  104 -> 44
  105 -> 34
  106 -> 119
  107 -> 97
  108 -> 115
  109 -> 109
  110 -> 95
  111 -> 115
  112 -> 116
  113 -> 97
  114 -> 116
  115 -> 115
  116 -> 46
  117 -> 116
  118 -> 120
  119 -> 116
  120 -> 34
  121 -> 58
  122 -> 34
  123 -> 34
  124 -> 125
  125 -> 125
  _ -> 0

json_selfhost_ok_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 116
  7 -> 114
  8 -> 117
  9 -> 101
  10 -> 44
  11 -> 34
  12 -> 97
  13 -> 114
  14 -> 116
  15 -> 105
  16 -> 102
  17 -> 97
  18 -> 99
  19 -> 116
  20 -> 115
  21 -> 34
  22 -> 58
  23 -> 123
  24 -> 34
  25 -> 109
  26 -> 101
  27 -> 114
  28 -> 103
  29 -> 101
  30 -> 100
  31 -> 95
  32 -> 109
  33 -> 111
  34 -> 100
  35 -> 117
  36 -> 108
  37 -> 101
  38 -> 46
  39 -> 116
  40 -> 120
  41 -> 116
  42 -> 34
  43 -> 58
  44 -> 34
  45 -> 34
  46 -> 44
  47 -> 34
  48 -> 116
  49 -> 121
  50 -> 112
  51 -> 101
  52 -> 95
  53 -> 105
  54 -> 110
  55 -> 102
  56 -> 111
  57 -> 46
  58 -> 116
  59 -> 120
  60 -> 116
  61 -> 34
  62 -> 58
  63 -> 34
  64 -> 34
  65 -> 44
  66 -> 34
  67 -> 116
  68 -> 121
  69 -> 112
  70 -> 101
  71 -> 95
  72 -> 105
  73 -> 110
  74 -> 102
  75 -> 111
  76 -> 95
  77 -> 101
  78 -> 114
  79 -> 114
  80 -> 111
  81 -> 114
  82 -> 46
  83 -> 116
  84 -> 120
  85 -> 116
  86 -> 34
  87 -> 58
  88 -> 34
  89 -> 34
  90 -> 44
  91 -> 34
  92 -> 108
  93 -> 111
  94 -> 119
  95 -> 101
  96 -> 114
  97 -> 101
  98 -> 100
  99 -> 95
  100 -> 105
  101 -> 114
  102 -> 46
  103 -> 116
  104 -> 120
  105 -> 116
  106 -> 34
  107 -> 58
  108 -> 34
  109 -> 34
  110 -> 44
  111 -> 34
  112 -> 99
  113 -> 111
  114 -> 108
  115 -> 108
  116 -> 97
  117 -> 112
  118 -> 115
  119 -> 101
  120 -> 100
  121 -> 95
  122 -> 105
  123 -> 114
  124 -> 46
  125 -> 116
  126 -> 120
  127 -> 116
  128 -> 34
  129 -> 58
  130 -> 34
  131 -> 34
  132 -> 44
  133 -> 34
  134 -> 101
  135 -> 120
  136 -> 112
  137 -> 111
  138 -> 114
  139 -> 116
  140 -> 115
  141 -> 46
  142 -> 116
  143 -> 120
  144 -> 116
  145 -> 34
  146 -> 58
  147 -> 34
  148 -> 34
  149 -> 44
  150 -> 34
  151 -> 119
  152 -> 97
  153 -> 115
  154 -> 109
  155 -> 95
  156 -> 115
  157 -> 116
  158 -> 97
  159 -> 116
  160 -> 115
  161 -> 46
  162 -> 116
  163 -> 120
  164 -> 116
  165 -> 34
  166 -> 58
  167 -> 34
  168 -> 34
  169 -> 125
  170 -> 125
  _ -> 0

json_unknown_error_byte i = case i of
  0 -> 123
  1 -> 34
  2 -> 111
  3 -> 107
  4 -> 34
  5 -> 58
  6 -> 102
  7 -> 97
  8 -> 108
  9 -> 115
  10 -> 101
  11 -> 44
  12 -> 34
  13 -> 101
  14 -> 114
  15 -> 114
  16 -> 111
  17 -> 114
  18 -> 34
  19 -> 58
  20 -> 34
  21 -> 117
  22 -> 110
  23 -> 115
  24 -> 117
  25 -> 112
  26 -> 112
  27 -> 111
  28 -> 114
  29 -> 116
  30 -> 101
  31 -> 100
  32 -> 32
  33 -> 99
  34 -> 111
  35 -> 109
  36 -> 109
  37 -> 97
  38 -> 110
  39 -> 100
  40 -> 34
  41 -> 125
  _ -> 0

fill_json_compile_error out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_compile_error_byte i)
    in fill_json_compile_error next (i + 1) len

fill_json_error_prefix out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_error_prefix_byte i)
    in fill_json_error_prefix next (i + 1) len

fill_json_error_suffix out out_start i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out (out_start + i) (json_error_suffix_byte i)
    in fill_json_error_suffix next out_start (i + 1) len

fill_json_format_prefix out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_format_prefix_byte i)
    in fill_json_format_prefix next (i + 1) len

fill_json_format_suffix out out_start i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out (out_start + i) (json_format_suffix_byte i)
    in fill_json_format_suffix next out_start (i + 1) len

fill_json_selfhost_prefix out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_selfhost_prefix_byte i)
    in fill_json_selfhost_prefix next (i + 1) len

fill_json_selfhost_suffix out out_start i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out (out_start + i) (json_selfhost_suffix_byte i)
    in fill_json_selfhost_suffix next out_start (i + 1) len

fill_json_selfhost_ok out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_selfhost_ok_byte i)
    in fill_json_selfhost_ok next (i + 1) len

fill_json_unknown_error out i len = case (i == len) of
  true -> out
  _ ->
    let next = slice_set_u8 out i (json_unknown_error_byte i)
    in fill_json_unknown_error next (i + 1) len

error_response_from_message msg_txt =
  let msg = str_to_slice msg_txt
      msg_len = slice_len msg
  in json_response_with_slice_segment json_error_prefix json_error_suffix msg 0 msg_len

compile_not_implemented_response _ =
  error_response_from_message "native compile not implemented yet"

compile_missing_input_path_response _ =
  error_response_from_message "compile request missing input_path"

compile_missing_input_source_response _ =
  error_response_from_message "compile request missing input_source"

compile_error_response request_handle = compile_not_implemented_response request_handle

compile_stub_success_response _ =
  let prefix = str_to_slice "{\"ok\":true,\"wasm_base64\":\""
      wasm_b64 = str_to_slice "AGFzbQEAAAABEwNgAX8Bf2ACf38Bf2ADf39/AX8CAQADAgECBAQBcAABBQMBAAEGBwF/AUGAIAsHKgQEbWFpbgAACF9fbWVtb3J5AgAHX190YWJsZQEACl9faGVhcF9wdHIDAAkHAQBBAAsBAAoIAQYBDX9BAQsLAQA="
      suffix = str_to_slice "\",\"exports\":[],\"dts\":\"export {}\\n\"}"
      b64_len = slice_len wasm_b64
  in json_response_with_slice_segment prefix suffix wasm_b64 0 b64_len

compile_source_start request_handle req_len =
  find_input_source_start request_handle 0 req_len

compile_request_tag request_handle req_len =
  let input_path_start = find_input_path_start request_handle 0 req_len
      source_start = compile_source_start request_handle req_len
      input_path_end = input_path_end_for_request request_handle input_path_start req_len
      source_end = source_end_for_request request_handle source_start req_len
      input_path_missing = (input_path_start == req_len)
      input_path_end_missing = (input_path_end == req_len)
      input_path_empty = (input_path_end == input_path_start)
      has_path = bool_not (bool_or input_path_missing (bool_or input_path_end_missing input_path_empty))
      has_source = bool_not (bool_or (source_start == req_len) (source_end == req_len))
  in case (bool_and has_path has_source) of
    true -> CompileRequestReady
    _ -> case has_path of
      true -> CompileRequestMissingSource
      _ -> CompileRequestMissingPath

input_path_end_for_request request_handle input_path_start req_len =
  case (input_path_start == req_len) of
    true -> req_len
    _ -> find_source_end request_handle input_path_start req_len 0

source_end_for_request request_handle source_start req_len =
  case (source_start == req_len) of
    true -> req_len
    _ -> find_source_end request_handle source_start req_len 0

matches_literal_at request_handle start lit j lit_len = case (j == lit_len) of
  true -> true
  _ ->
    let req_byte = slice_get_u8 request_handle (start + j)
        key_byte = slice_get_u8 lit j
    in case (req_byte == key_byte) of
      true -> matches_literal_at request_handle start lit (j + 1) lit_len
      _ -> false

find_literal_start request_handle i req_len lit lit_len = case (i + lit_len <= req_len) of
  true -> find_literal_start_step request_handle i req_len lit lit_len
  _ -> req_len

find_literal_start_step request_handle i req_len lit lit_len =
  case (matches_literal_at request_handle i lit 0 lit_len) of
    true -> i
    _ -> find_literal_start request_handle (i + 1) req_len lit lit_len

find_compile_mode_start request_handle req_len =
  let key = str_to_slice "\"compile_mode\""
      key_len = slice_len key
      key_start = find_literal_start request_handle 0 req_len key key_len
  in case (key_start == req_len) of
    true -> req_len
    _ -> source_value_start_at request_handle (key_start + key_len) req_len

is_compile_mode_literal request_handle mode_start req_len mode_txt =
  let lit = str_to_slice mode_txt
      lit_len = slice_len lit
      in_bounds = mode_start + lit_len < req_len
  in bool_and in_bounds (is_compile_mode_literal_match request_handle mode_start lit lit_len)

is_compile_mode_literal_match request_handle mode_start lit lit_len =
  case (matches_literal_at request_handle mode_start lit 0 lit_len) of
    true -> (slice_get_u8 request_handle (mode_start + lit_len) == 34)
    _ -> false

is_compile_mode_stub_success request_handle req_len =
  let mode_start = find_compile_mode_start request_handle req_len
      has_mode = bool_not (mode_start == req_len)
  in bool_and has_mode (is_compile_mode_literal request_handle mode_start req_len "stub-success")

compile_response request_handle =
  let req_len = slice_len request_handle
  in case (req_len > max_inline_request_len) of
    true -> compile_not_implemented_response request_handle
    _ ->
      case (req_len > max_inline_validation_request_len) of
        true -> compile_stub_success_response request_handle
        _ ->
          let tag = compile_request_tag request_handle req_len
          in case tag of
            CompileRequestMissingPath -> compile_missing_input_path_response request_handle
            CompileRequestMissingSource -> compile_missing_input_source_response request_handle
            CompileRequestReady -> compile_stub_success_response request_handle

is_space_byte b =
  let is_space_32 = (b == 32)
      is_space_9 = (b == 9)
      is_space_10 = (b == 10)
      is_space_13 = (b == 13)
  in bool_or is_space_32 (bool_or is_space_9 (bool_or is_space_10 is_space_13))

skip_ws request_handle i req_len = case (i < req_len) of
  true -> skip_ws_step request_handle i req_len
  _ -> req_len

skip_ws_step request_handle i req_len =
  let b = slice_get_u8 request_handle i
  in case (is_space_byte b) of
    true -> skip_ws request_handle (i + 1) req_len
    _ -> i

source_value_start_at request_handle key_end req_len =
  let colon_at = skip_ws request_handle key_end req_len
  in case (colon_at < req_len) of
    true -> source_value_start_at_colon request_handle colon_at req_len
    _ -> req_len

source_value_start_at_colon request_handle colon_at req_len =
  case (slice_get_u8 request_handle colon_at == 58) of
    true -> source_value_start_at_quote request_handle colon_at req_len
    _ -> req_len

source_value_start_at_quote request_handle colon_at req_len =
  let quote_at = skip_ws request_handle (colon_at + 1) req_len
  in case (quote_at < req_len) of
    true -> source_value_start_at_quote_check request_handle quote_at req_len
    _ -> req_len

source_value_start_at_quote_check request_handle quote_at req_len =
  case (slice_get_u8 request_handle quote_at == 34) of
    true -> quote_at + 1
    _ -> req_len

find_json_key_value_start request_handle i req_len key_txt =
  let parse_key = parser_bind
        (parse_json_key_value_end request_handle i req_len key_txt)
        (parse_json_key_value_end_to_start request_handle)
      r = parse_key request_handle i req_len
  in case (r == -1) of
    true -> req_len
    _ -> r

parse_json_key_value_end request_handle i req_len key_txt =
  let key = str_to_slice key_txt
      key_len = slice_len key
      key_start = find_literal_start request_handle i req_len key key_len
  in case (key_start == req_len) of
    true -> -1
    _ -> key_start + key_len

parse_json_key_value_end_to_start request_handle i req_len =
  source_value_start_at request_handle i req_len

find_source_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"source\""

find_input_source_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"input_source\""

find_input_path_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"input_path\""

max_source_scan_steps = 8192
max_inline_request_len = 32768
max_inline_validation_request_len = 2048

find_source_end request_handle i req_len slash_parity =
  find_source_end_limited request_handle i req_len slash_parity 0

find_source_end_limited request_handle i req_len slash_parity steps =
  case (steps == max_source_scan_steps) of
    true -> req_len
    _ ->
      case (i < 0) (i >= req_len) of
        true _ -> req_len
        _ true -> req_len
        _ _ -> find_source_end_limited_step request_handle i req_len slash_parity steps

find_source_end_limited_step request_handle i req_len slash_parity steps =
  let b = slice_get_u8 request_handle i
  in case (b == 92) (b == 34) of
    true _ -> find_source_end_limited request_handle (i + 1) req_len (1 - slash_parity) (steps + 1)
    _ true -> find_source_end_limited_quote request_handle i req_len slash_parity steps
    _ _ -> find_source_end_limited request_handle (i + 1) req_len 0 (steps + 1)

find_source_end_limited_quote request_handle i req_len slash_parity steps =
  case (slash_parity == 0) of
    true -> i
    _ -> find_source_end_limited request_handle (i + 1) req_len 0 (steps + 1)

copy_slice_segment src src_start dst dst_start seg_len i = case (i == seg_len) of
  true -> dst
  _ ->
    case (i + 16 <= seg_len) of
      true ->
        let b0 = slice_get_u8 src (src_start + i)
            d0 = slice_set_u8 dst (dst_start + i) b0
            b1 = slice_get_u8 src (src_start + i + 1)
            d1 = slice_set_u8 d0 (dst_start + i + 1) b1
            b2 = slice_get_u8 src (src_start + i + 2)
            d2 = slice_set_u8 d1 (dst_start + i + 2) b2
            b3 = slice_get_u8 src (src_start + i + 3)
            d3 = slice_set_u8 d2 (dst_start + i + 3) b3
            b4 = slice_get_u8 src (src_start + i + 4)
            d4 = slice_set_u8 d3 (dst_start + i + 4) b4
            b5 = slice_get_u8 src (src_start + i + 5)
            d5 = slice_set_u8 d4 (dst_start + i + 5) b5
            b6 = slice_get_u8 src (src_start + i + 6)
            d6 = slice_set_u8 d5 (dst_start + i + 6) b6
            b7 = slice_get_u8 src (src_start + i + 7)
            d7 = slice_set_u8 d6 (dst_start + i + 7) b7
            b8 = slice_get_u8 src (src_start + i + 8)
            d8 = slice_set_u8 d7 (dst_start + i + 8) b8
            b9 = slice_get_u8 src (src_start + i + 9)
            d9 = slice_set_u8 d8 (dst_start + i + 9) b9
            b10 = slice_get_u8 src (src_start + i + 10)
            d10 = slice_set_u8 d9 (dst_start + i + 10) b10
            b11 = slice_get_u8 src (src_start + i + 11)
            d11 = slice_set_u8 d10 (dst_start + i + 11) b11
            b12 = slice_get_u8 src (src_start + i + 12)
            d12 = slice_set_u8 d11 (dst_start + i + 12) b12
            b13 = slice_get_u8 src (src_start + i + 13)
            d13 = slice_set_u8 d12 (dst_start + i + 13) b13
            b14 = slice_get_u8 src (src_start + i + 14)
            d14 = slice_set_u8 d13 (dst_start + i + 14) b14
            b15 = slice_get_u8 src (src_start + i + 15)
            d15 = slice_set_u8 d14 (dst_start + i + 15) b15
        in copy_slice_segment src src_start d15 dst_start seg_len (i + 16)
      _ ->
        let b = slice_get_u8 src (src_start + i)
            next = slice_set_u8 dst (dst_start + i) b
        in copy_slice_segment src src_start next dst_start seg_len (i + 1)

json_escape_extra_len src start seg_len i extra = case (i == seg_len) of
  true -> extra
  _ ->
    let b = slice_get_u8 src (start + i)
    in case (b == 34) (b == 92) (b == 10) (b == 13) (b == 9) of
      true _ _ _ _ -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ true _ _ _ -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ _ true _ _ -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ _ _ true _ -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ _ _ _ true -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ _ _ _ _ -> json_escape_extra_len src start seg_len (i + 1) extra

json_copy_escaped_segment src start seg_len i dst dst_i = case (i == seg_len) of
  true -> dst
  _ ->
    let b = slice_get_u8 src (start + i)
    in case (b == 34) (b == 92) (b == 10) (b == 13) (b == 9) of
      true _ _ _ _ ->
        let d1 = slice_set_u8 dst dst_i 92
            d2 = slice_set_u8 d1 (dst_i + 1) 34
        in json_copy_escaped_segment src start seg_len (i + 1) d2 (dst_i + 2)
      _ true _ _ _ ->
        let d1 = slice_set_u8 dst dst_i 92
            d2 = slice_set_u8 d1 (dst_i + 1) 92
        in json_copy_escaped_segment src start seg_len (i + 1) d2 (dst_i + 2)
      _ _ true _ _ ->
        let d1 = slice_set_u8 dst dst_i 92
            d2 = slice_set_u8 d1 (dst_i + 1) 110
        in json_copy_escaped_segment src start seg_len (i + 1) d2 (dst_i + 2)
      _ _ _ true _ ->
        let d1 = slice_set_u8 dst dst_i 92
            d2 = slice_set_u8 d1 (dst_i + 1) 114
        in json_copy_escaped_segment src start seg_len (i + 1) d2 (dst_i + 2)
      _ _ _ _ true ->
        let d1 = slice_set_u8 dst dst_i 92
            d2 = slice_set_u8 d1 (dst_i + 1) 116
        in json_copy_escaped_segment src start seg_len (i + 1) d2 (dst_i + 2)
      _ _ _ _ _ ->
        let d1 = slice_set_u8 dst dst_i b
        in json_copy_escaped_segment src start seg_len (i + 1) d1 (dst_i + 1)

json_response_with_literal_prefix_suffix prefix suffix =
  let prefix_len = slice_len prefix
      suffix_len = slice_len suffix
      out = slice_new_u8 (prefix_len + suffix_len)
      out1 = copy_slice_literal out 0 prefix
  in copy_slice_literal out1 prefix_len suffix

json_response_with_slice_segment prefix suffix src src_start src_len =
  let prefix_len = slice_len prefix
      suffix_len = slice_len suffix
      total_len = prefix_len + src_len + suffix_len
      out = slice_new_u8 total_len
      out1 = copy_slice_literal out 0 prefix
      out2 = copy_slice_segment src src_start out1 prefix_len src_len 0
  in copy_slice_literal out2 (prefix_len + src_len) suffix

json_response_with_escaped_slice_segment prefix suffix src src_start src_len =
  let prefix_len = slice_len prefix
      escaped_extra = json_escape_extra_len src src_start src_len 0 0
      escaped_len = src_len + escaped_extra
      suffix_len = slice_len suffix
      total_len = prefix_len + escaped_len + suffix_len
      out = slice_new_u8 total_len
      out1 = copy_slice_literal out 0 prefix
      out2 = json_copy_escaped_segment src src_start src_len 0 out1 prefix_len
  in copy_slice_literal out2 (prefix_len + escaped_len) suffix

json_response_from_slice literal =
  let out = slice_new_u8 (slice_len literal)
      out1 = copy_slice_literal out 0 literal
  in out1

json_slice_end request_handle source_start req_len =
  let source_end_raw = find_source_end request_handle source_start req_len 0
  in case (source_end_raw < source_start) (source_end_raw > req_len) of
    true _ -> source_start
    _ true -> req_len
    _ _ -> source_end_raw

format_empty_response _ =
  json_response_with_literal_prefix_suffix json_format_prefix json_format_suffix

format_source_response request_handle source_start req_len =
  let source_end = json_slice_end request_handle source_start req_len
      source_len = source_end - source_start
  in json_response_with_slice_segment
    json_format_prefix
    json_format_suffix
    request_handle
    source_start
    source_len

format_ok_response request_handle =
  let req_len = slice_len request_handle
      source_start = find_source_start request_handle 0 req_len
  in case (source_start == req_len) of
    true -> format_empty_response request_handle
    _ -> format_source_response request_handle source_start req_len

selfhost_empty_response _ =
  json_response_with_literal_prefix_suffix json_selfhost_prefix json_selfhost_suffix

selfhost_source_response request_handle source_start req_len =
  let source_end = json_slice_end request_handle source_start req_len
      source_len = source_end - source_start
  in json_response_with_escaped_slice_segment
    json_selfhost_prefix
    json_selfhost_suffix
    request_handle
    source_start
    source_len

selfhost_ok_response_no_input_source request_handle req_len =
  error_response_from_message "selfhost-artifacts request missing input_source"

selfhost_ok_response request_handle =
  let req_len = slice_len request_handle
      source_start = find_input_source_start request_handle 0 req_len
  in case (source_start == req_len) of
    true -> selfhost_ok_response_no_input_source request_handle req_len
    _ -> selfhost_source_response request_handle source_start req_len

unknown_error_response _ =
  json_response_from_slice json_unknown_error

is_command_literal request_handle start req_len lit_txt =
  is_compile_mode_literal request_handle start req_len lit_txt

command_tag_code_compile _ = 1
command_tag_code_format _ = 2
command_tag_code_selfhost _ = 3

parse_command_tag request_handle value_start req_len command =
  case is_command_literal request_handle value_start req_len command of
    true -> value_start
    _ -> -1

parse_command_tag_code request_handle value_start req_len =
  let compile_tag = parser_map command_tag_code_compile (parse_command_tag request_handle value_start req_len "compile")
      format_tag = parser_map command_tag_code_format (parse_command_tag request_handle value_start req_len "format")
      selfhost_tag = parser_map command_tag_code_selfhost (parse_command_tag request_handle value_start req_len "selfhost-artifacts")
  in parser_or compile_tag (parser_or format_tag selfhost_tag) request_handle value_start req_len

command_tag_of request_handle value_start req_len command tag =
  case is_command_literal request_handle value_start req_len command of
    true -> Just tag
    _ -> Nothing

command_tag_at request_handle value_start req_len =
  let command = parse_command_tag_code request_handle value_start req_len
  in case command of
    1 -> Just CommandCompile
    2 -> Just CommandFormat
    3 -> Just CommandSelfhost
    _ -> Nothing

find_command_tag request_handle i req_len =
  let value_start = find_json_key_value_start request_handle i req_len "\"command\""
  in case (value_start == req_len) of
    true -> Nothing
    _ -> command_tag_at request_handle value_start req_len

command_tag request_handle =
  let req_len = slice_len request_handle
      scan_limit = 256
      scan_len = min2 req_len scan_limit
      raw_tag = find_command_tag request_handle 0 scan_len
  in case raw_tag of
    Nothing -> CommandUnknown
    Just tag -> tag

clapse_run request_handle =
  let tag = command_tag request_handle
  in case tag of
    CommandCompile -> compile_response request_handle
    CommandFormat -> format_ok_response request_handle
    CommandSelfhost -> selfhost_ok_response request_handle
    CommandUnknown -> unknown_error_response request_handle
