module compiler.formatter
import compiler.prelude
export format_ok_response

data OwnershipRewriteMode = OwnershipRewriteLinear | OwnershipRewriteCopyOnWrite
data MonadicLine = MonadicLineNil
  | MonadicLineNode
    Int
    Int
    Int
    Int
    Int
    Int
    MonadicLine
data ParsedLine = ParsedLine MonadicLine Int
data ChainCollect = ChainCollect MonadicLine Int Int Int Int

json_format_prefix = str_to_slice "{\"ok\":true,\"formatted\":\""
json_format_suffix = str_to_slice "\"}"

copy_slice_literal request_handle ownership_mode out out_start txt =
  copy_slice_segment request_handle ownership_mode txt 0 out out_start (slice_len txt) 0


is_space_byte b =
  let is_space_32 = (b == format_space_byte)
      is_space_9 = (b == format_tab_byte)
      is_space_10 = (b == format_newline_byte)
      is_space_13 = (b == format_carriage_return_byte)
  in is_space_32 || is_space_9 || is_space_10 || is_space_13

max2 a b = case (a > b) of
  true -> a
  _ -> b

format_default_line_width = 100
format_continuation_spaces = 2
format_newline_byte = byte '\n'
format_carriage_return_byte = byte '\r'
format_space_byte = byte ' '
format_tab_byte = byte '\t'
format_quote_byte = char '"'
format_escape_byte = char '\\'
format_backslash_byte = char '\\'
format_dash_byte = char '-'
format_form_feed_byte = char '\f'
format_backspace_byte = char '\b'
format_slash_byte = char '/'
format_eq_byte = char '='
format_gt_byte = char '>'
format_amp_byte = char '&'
format_bar_byte = char '|'
format_escape_n_byte = char 'n'
format_escape_r_byte = char 'r'
format_escape_t_byte = char 't'
format_escape_b_byte = char 'b'
format_escape_f_byte = char 'f'
format_is_space_or_tab b = (b == format_space_byte) || (b == format_tab_byte)

format_unescape_source_loop request_handle source_start source_end out out_i i =
  case (source_start + i >= source_end) of
    true -> out_i
    _ ->
      let b = slice_get_u8 request_handle (source_start + i)
      in case (b == format_escape_byte) of
        true ->
          case (source_start + i + 1 >= source_end) of
            true ->
              let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i b
              in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 1)
            _ ->
              let e = slice_get_u8 request_handle (source_start + i + 1)
              in case e of
                format_quote_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_quote_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_backslash_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_escape_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_n_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_newline_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_r_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_carriage_return_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_t_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_tab_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_b_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_backspace_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_f_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_form_feed_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_slash_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_slash_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                _ ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i e
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
        _ ->
          let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i b
          in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 1)

format_find_comment_start_loop request_handle line_start line_end i in_string escaped =
  case (line_start + i >= line_end) of
    true -> Nothing
    _ ->
      let at = line_start + i
          b = slice_get_u8 request_handle at
          is_quote = b == format_quote_byte
          is_escape = b == format_escape_byte
          is_dash = b == format_dash_byte
          is_comment = is_dash && (at + 1 < line_end) && (slice_get_u8 request_handle (at + 1) == format_dash_byte)
          has_string_escape = in_string && escaped
          has_string_escape_char = in_string && !escaped && is_escape
          has_string_quote = in_string && !escaped && is_quote
          has_comment_start = !in_string && is_comment
          has_enter_string = !in_string && is_quote
      let comment_start_state =
            case has_string_escape has_string_escape_char has_string_quote has_enter_string has_comment_start of
              true _ _ _ _ -> 0
              _ true _ _ _ -> 1
              _ _ true _ _ -> 2
              _ _ _ true _ -> 3
              _ _ _ _ true -> 4
              _ _ _ _ _ -> 5
      in case comment_start_state of
        0 -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true false
        1 -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true true
        2 -> format_find_comment_start_loop request_handle line_start line_end (i + 1) false false
        3 -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true false
        4 -> Just at
        _ -> format_find_comment_start_loop request_handle line_start line_end (i + 1) false false

format_find_comment_start request_handle line_start line_end =
  format_find_comment_start_loop request_handle line_start line_end 0 false false

format_leading_space_len request_handle line_start line_end i =
  case (line_start + i >= line_end) of
    true -> i
    _ ->
      case format_is_space_or_tab (slice_get_u8 request_handle (line_start + i)) of
        true -> format_leading_space_len request_handle line_start line_end (i + 1)
        _ -> i

format_trim_trailing_spaces request_handle scratch start i =
  case (i <= start) of
    true -> i
    _ ->
      let at = i - 1
      in case format_is_space_or_tab (slice_get_u8 request_handle at) of
        true -> format_trim_trailing_spaces request_handle scratch start (i - 1)
        _ -> i

format_collapse_code request_handle ownership_mode source start end scratch out_i i in_string escaped prev_space =
  case (start + i >= end) of
    true -> out_i
    _ ->
      let b = slice_get_u8 request_handle (start + i)
          is_escape = b == format_escape_byte
          is_quote = b == format_quote_byte
          is_space = format_is_space_or_tab b
          is_space_or_start = prev_space || (out_i == 0)
          next_char = slice_set_u8 request_handle ownership_mode scratch out_i b
          is_string_escape = in_string && escaped
          is_string_escape_char = in_string && !escaped && is_escape
          is_string_quote = in_string && !escaped && is_quote
          is_string_data = in_string && !escaped && !is_escape && !is_quote && !is_space
          is_space_outside = !in_string && is_space
          is_space_at_segment_start = is_space_outside && is_space_or_start
      let collapse_state =
            case is_string_escape is_string_escape_char is_string_quote is_string_data is_space_outside is_space_at_segment_start of
              true _ _ _ _ _ _ -> 0
              _ true _ _ _ _ _ -> 1
              _ _ true _ _ _ _ -> 2
              _ _ _ true _ _ _ -> 3
              _ _ _ _ _ true -> 4
              _ _ _ _ true false _ -> 5
              _ _ _ _ _ _ _ -> 6
      in case collapse_state of
        0 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true false prev_space
        1 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true true prev_space
        2 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) false false prev_space
        3 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true false prev_space
        4 ->
          format_collapse_code request_handle ownership_mode source start end scratch out_i (i + 1) false false true
        5 ->
          let next_space = slice_set_u8 request_handle ownership_mode scratch out_i format_space_byte
          in format_collapse_code request_handle ownership_mode source start end next_space (out_i + 1) (i + 1) false false true
        _ ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) false false false

format_normalize_line request_handle ownership_mode source line_start line_end scratch =
  let comment_start = format_find_comment_start request_handle line_start line_end
      code_end = maybe_with_default line_end comment_start
      indent_len = format_leading_space_len request_handle line_start code_end 0
      compact_end = format_collapse_code request_handle ownership_mode source (line_start + indent_len) code_end scratch indent_len 0 false false false
      compact_trim = format_trim_trailing_spaces request_handle scratch compact_end compact_end
      copied_prefix = copy_slice_segment request_handle source line_start scratch 0 indent_len 0
      comment_len = maybe_with_default 0
        (maybe_map
          (\at ->
            let len = line_end - at
            in copy_slice_segment request_handle source at copied_prefix compact_trim len 0
               in len)
          comment_start)
  in compact_trim + comment_len

format_copy_spaces request_handle ownership_mode out out_i count =
  case (count <= 0) of
    true -> out_i
    _ ->
      let next = slice_set_u8 request_handle ownership_mode out out_i format_space_byte
      in format_copy_spaces request_handle ownership_mode out (out_i + 1) (count - 1)

format_find_wrap_token_loop request_handle source start len width i in_string escaped best =
  case (i > width || i >= len) of
    true -> best
    _ ->
      let at = start + i
          b = slice_get_u8 request_handle at
          max_i = max2 width len
          is_quote = b == format_quote_byte
          is_escape = b == format_escape_byte
          is_string_escape = in_string && escaped
          is_string_escape_char = in_string && !escaped && is_escape
          is_string_quote = in_string && !escaped && is_quote
          is_entering_string = !in_string && is_quote
      let wrap_token_state =
            case is_string_escape is_string_escape_char is_string_quote is_entering_string of
              true _ _ _ -> 0
              _ true _ _ -> 1
              _ _ true _ -> 2
              _ _ _ true -> 3
              _ _ _ _ -> 4
      in case wrap_token_state of
        0 -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) false false best
        1 -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) true true best
        2 -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) false false best
        3 -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) true false best
        _ ->
          let has_space = (b == format_space_byte)
              token1 =
                has_space
                && (i + 3 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_eq_byte)
                && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 3) == format_space_byte)
              token2 =
                has_space
                && (i + 2 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_eq_byte)
                && (slice_get_u8 request_handle (at + 2) == format_space_byte)
              token3 =
                has_space
                && (i + 3 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_dash_byte)
                && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 3) == format_space_byte)
              token4 =
                has_space
                && (i + 5 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 3) == format_eq_byte)
                && (slice_get_u8 request_handle (at + 4) == format_space_byte)
              token5 =
                has_space
                && (i + 3 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 3) == format_space_byte)
              token6 =
                has_space
                && (i + 3 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_amp_byte)
                && (slice_get_u8 request_handle (at + 2) == format_amp_byte)
                && (slice_get_u8 request_handle (at + 3) == format_space_byte)
              token7 =
                has_space
                && (i + 3 <= max_i)
                && (slice_get_u8 request_handle (at + 1) == format_bar_byte)
                && (slice_get_u8 request_handle (at + 2) == format_bar_byte)
                && (slice_get_u8 request_handle (at + 3) == format_space_byte)
          has_wrap_token = token1 || token2 || token3 || token4 || token5 || token6 || token7
          in case has_wrap_token of
            true -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) false false i
            _ -> format_find_wrap_token_loop request_handle source start len max_i (i + 1) false false best

format_find_wrap_break request_handle line start len width =
  let max_i = max2 width len
      token = format_find_wrap_token_loop request_handle line start len max_i 0 false false -1
      has_token = token >= 0
    in case has_token of
      true -> token
      _ -> format_find_wrap_whitespace request_handle line start len max_i

format_find_wrap_whitespace request_handle source start len width =
  case (width <= 0) of
    true -> -1
    _ ->
      let scan i best in_string escaped =
        case (i >= width || i >= len) of
          true -> best
          _ ->
            let at = start + i
                b = slice_get_u8 request_handle at
                is_quote = b == format_quote_byte
                is_escape = b == format_escape_byte
                is_space = format_is_space_or_tab b
                is_string_escape = in_string && escaped
                is_string_escape_char = in_string && !escaped && is_escape
                is_string_quote = in_string && !escaped && is_quote
                is_entering_string = !in_string && is_quote
                is_whitespace = is_space
                whitespace_state =
                  case is_string_escape is_string_escape_char is_string_quote is_entering_string is_whitespace of
                    true _ _ _ _ -> 0
                    _ true _ _ _ -> 1
                    _ _ true _ _ -> 2
                    _ _ _ true _ -> 3
                    _ _ _ _ true -> 4
                    _ _ _ _ _ -> 5
            in case whitespace_state of
              0 -> scan (i + 1) best false false
              1 -> scan (i + 1) best true false
              2 -> scan (i + 1) best false false
              3 -> scan (i + 1) best true false
              4 -> scan (i + 1) i false false
              _ -> scan (i + 1) best false false
      in scan 0 -1 false false

format_emit_wrap_prefix request_handle ownership_mode line base_indent_len is_cont out out_i =
  let out1 = copy_slice_segment request_handle ownership_mode line 0 out out_i base_indent_len 0
  in case is_cont of
    true -> format_copy_spaces request_handle ownership_mode out1 (out_i + base_indent_len) format_continuation_spaces
    _ -> out_i + base_indent_len

format_copy_segment request_handle ownership_mode source source_start out out_i segment_len =
  case (segment_len <= 0) of
    true -> out_i
    _ ->
      copy_slice_segment request_handle ownership_mode source source_start out out_i segment_len 0
      out_i + segment_len

format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len source_start source_len out out_i has_more is_cont =
  let is_empty = source_len <= 0
  in let wrap_state =
         case is_empty has_more of
           true true -> 0
           true false -> 1
           _ -> 2
     in case wrap_state of
       0 -> slice_set_u8 request_handle ownership_mode out out_i format_newline_byte
       1 -> out_i
       _ ->
         let avail = case is_cont of
            true -> max2 1 (format_default_line_width - (base_indent_len + format_continuation_spaces))
            _ -> max2 1 (format_default_line_width - base_indent_len)
          first_break = format_find_wrap_break request_handle line source_start source_len avail
          has_empty_break = first_break <= 0
          chunk_len = case has_empty_break of
            true -> avail
            _ -> first_break
          out1 = format_emit_wrap_prefix request_handle ownership_mode line base_indent_len is_cont out out_i
          out2 = format_copy_segment request_handle line source_start out1 chunk_len
          is_last_chunk = source_len <= chunk_len
      in let last_chunk_state =
           case is_last_chunk has_more of
             true true -> 0
             true false -> 1
             _ -> 2
         in case last_chunk_state of
           0 -> slice_set_u8 request_handle ownership_mode out2 out2 format_newline_byte
           1 -> out2
           _ ->
             let out3 = slice_set_u8 request_handle ownership_mode out2 out2 format_newline_byte
             in format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len (source_start + chunk_len) (source_len - chunk_len) out3 true true

format_wrap_line request_handle ownership_mode line line_len base_indent_len out out_i has_more =
  let source_len = case (line_len <= base_indent_len) of
    true -> 0
    _ -> line_len - base_indent_len
  in format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len base_indent_len source_len out out_i has_more false

format_line_end request_handle i end =
  case (i >= end) of
    true -> end
    _ ->
      let b = slice_get_u8 request_handle i
      in case (b == format_newline_byte) of
        true -> i
        _ -> format_line_end request_handle (i + 1) end

format_normalize_source_lines request_handle ownership_mode source source_len out out_i i =
  case (i >= source_len) of
    true -> out_i
    _ ->
      let line_end = format_line_end request_handle i source_len
          has_carriage_return = line_end > i && slice_get_u8 request_handle (line_end - 1) == format_carriage_return_byte
          content_end = case has_carriage_return of
            true -> line_end - 1
            _ -> line_end
          line_len = content_end - i
          scratch = slice_new_u8 (line_len + format_default_line_width + 8)
          scratch_len = format_normalize_line request_handle ownership_mode source i content_end scratch
          content_start = format_leading_space_len request_handle 0 scratch_len 0
          has_next_line = line_end < source_len
          is_empty_line = line_len <= 0
          out1 =
            let empty_line_state =
              case is_empty_line has_next_line of
                true true -> 0
                true false -> 1
                _ -> 2
            in case empty_line_state of
              0 -> slice_set_u8 request_handle ownership_mode out out_i format_newline_byte
              1 -> out_i
              _ -> format_wrap_line request_handle ownership_mode scratch scratch_len content_start out out_i has_next_line
          next_i = case has_next_line of
            true -> line_end + 1
            _ -> line_end
      in format_normalize_source_lines request_handle ownership_mode source source_len out1 next_i

format_skip_spaces request_handle i end =
  case (i >= end) of
    true -> i
    _ ->
      let b = slice_get_u8 request_handle i
      in case (format_is_space_or_tab b) of
        true -> format_skip_spaces request_handle (i + 1) end
        _ -> i

format_trim_right request_handle i start =
  case (i <= start) of
    true -> start
    _ ->
      let at = i - 1
      in case (format_is_space_or_tab (slice_get_u8 request_handle at)) of
        true -> format_trim_right request_handle at start
        _ -> i

format_has_nonspace request_handle i end =
  case (i >= end) of
    true -> false
    _ ->
      let b = slice_get_u8 request_handle i
      in case (format_is_space_or_tab b) of
        true -> format_has_nonspace request_handle (i + 1) end
        _ -> true

format_find_comment_boundary request_handle line_start line_end =
  let comment_start = format_find_comment_start request_handle line_start line_end
  in maybe_with_default line_end comment_start

format_has_content_outside_comment request_handle line_start line_end =
  let content_end = format_find_comment_boundary request_handle line_start line_end
  in format_has_nonspace request_handle line_start content_end

format_has_backslash_arrow request_handle start end =
  case (start >= end) of
    true -> false
    _ ->
      let b = slice_get_u8 request_handle start
      in case (b == format_backslash_byte) of
        true ->
          let next = case (start + 1 < end) of
            true -> start + 1
            _ -> end
          in format_has_arrow request_handle next end
        _ -> format_has_backslash_arrow request_handle (start + 1) end

format_has_arrow request_handle start end =
  case (start + 1 >= end) of
    true -> false
    _ ->
      let is_dash = slice_get_u8 request_handle start == format_dash_byte
          is_arrow = (slice_get_u8 request_handle (start + 1)) == format_gt_byte
      in let has_dash_arrow =
           is_dash && is_arrow
         in case has_dash_arrow of
              true -> true
              _ -> format_has_arrow request_handle (start + 1) end

format_find_monadic_operator request_handle source start end i in_string escaped =
  let at = start + i
  in case (at >= end) of
    true -> -1
    _ ->
      let b = slice_get_u8 request_handle at
          is_escape = b == format_escape_byte
          is_quote = b == format_quote_byte
          is_string_escape = in_string && escaped
          is_string_escape_char = in_string && !escaped && is_escape
          is_string_quote = in_string && !escaped && is_quote
      in let monadic_operator_state =
            case is_string_escape is_string_escape_char is_string_quote is_quote of
              true _ _ _ -> 0
              _ true _ _ -> 1
              _ _ true _ -> 2
              _ _ _ true -> 3
              _ _ _ _ -> 4
         in case monadic_operator_state of
           0 -> format_find_monadic_operator request_handle source start end (i + 1) false false
           1 -> format_find_monadic_operator request_handle source start end (i + 1) true true
           2 -> format_find_monadic_operator request_handle source start end (i + 1) false false
           3 -> format_find_monadic_operator request_handle source start end (i + 1) true false
           _ ->
             let is_bind3 =
                (at + 2 < end)
                && (b == format_gt_byte)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 2) == format_eq_byte)
              is_bind2 =
                (at + 1 < end)
                && (b == format_gt_byte)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
             in case (is_bind3 || is_bind2) of
               true -> start + i
               _ -> format_find_monadic_operator request_handle source start end (i + 1) false false

format_monadic_operator_length request_handle source op_start end =
  case (op_start + 3 < end) of
    true ->
      let has_bind_3_bytes =
        (slice_get_u8 request_handle op_start == format_gt_byte)
        && (slice_get_u8 request_handle (op_start + 1) == format_gt_byte)
        && (slice_get_u8 request_handle (op_start + 2) == format_eq_byte)
      in case has_bind_3_bytes of
        true -> 3
        _ -> 2
    _ -> 2

format_parse_monadic_line request_handle source line_start line_end =
  let content_end = format_find_comment_boundary request_handle line_start line_end
      has_content = format_has_nonspace request_handle line_start content_end
  in case has_content of
    false -> ParsedLine MonadicLineNil 0
    _ ->
      let indent = format_leading_space_len request_handle line_start line_end 0
          op_pos = format_find_monadic_operator request_handle source line_start content_end 0 false false
      in case (op_pos == -1) of
        true -> ParsedLine MonadicLineNil 0
        _ ->
          let op_len = format_monadic_operator_length request_handle source op_pos content_end
              rest_start = format_skip_spaces request_handle (op_pos + op_len) content_end
              rest_end = format_trim_right request_handle content_end rest_start
              has_lambda = case (rest_start < rest_end) of
                true -> format_has_backslash_arrow request_handle rest_start rest_end
                _ -> false
              has_rest = rest_start < rest_end
              is_multiline =
                has_rest
                && (rest_end - rest_start > 1)
                && (slice_get_u8 request_handle rest_start == format_backslash_byte)
                && (slice_get_u8 request_handle (rest_end - 2) == format_dash_byte)
                && (slice_get_u8 request_handle (rest_end - 1) == format_gt_byte)
              has_lambda_flag = case has_lambda of
                true -> 1
                _ -> 0
              is_multiline_flag = case is_multiline of
                true -> 2
                _ -> 0
              flags =
                has_lambda_flag + is_multiline_flag
              in ParsedLine (MonadicLineNode line_start line_end indent op_pos op_len rest_start MonadicLineNil) flags

format_monadic_indent node =
  case node of
    MonadicLineNode _ _ indent _ _ _ _ -> indent
    _ -> 0

format_copy_raw_line request_handle source line_start line_end out out_i source_end =
  let out1 = format_copy_segment request_handle OwnershipRewriteLinear source line_start out out_i (line_end - line_start)
  in case (line_end < source_end) of
    true -> slice_set_u8 request_handle OwnershipRewriteLinear out1 out1 format_newline_byte
    _ -> out1

format_copy_line_with_indent request_handle source line_start line_end indent out out_i source_end =
  let trimmed = format_leading_space_len request_handle line_start line_end 0
      line_len = line_end - line_start
      body_start = line_start + trimmed
      body_len = line_len - trimmed
      out1 = format_copy_spaces request_handle OwnershipRewriteLinear out out_i indent
      out2 = format_copy_segment request_handle OwnershipRewriteLinear source body_start out1 (out_i + indent) body_len
      out3 = case (line_end < source_end) of
        true -> slice_set_u8 request_handle OwnershipRewriteLinear out2 out2 format_newline_byte
        _ -> out2
  in out3

format_next_line_start line_end source_end =
  case (line_end < source_end) of
    true -> line_end + 1
    _ -> line_end

format_collect_monadic_chain request_handle source source_len base_indent next_i count has_lambda has_multiline =
  case (next_i >= source_len) of
    true -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
    _ ->
      let line_end = format_line_end request_handle next_i source_len
          parsed = format_parse_monadic_line request_handle source next_i line_end
          next = format_next_line_start line_end source_len
      in case parsed of
        ParsedLine (MonadicLineNode _ _ indent _ _ _ _) flags ->
          let has_sufficient_indent = indent >= base_indent
          in case has_sufficient_indent of
            true ->
              let has_line_lambda = flags == 1 || flags == 3
                  has_chain_lambda = has_lambda == 1
                  has_chain_multiline = has_multiline == 1
                  has_next_lambda = has_chain_lambda || has_line_lambda
                  next_lambda = case has_next_lambda of
                    true -> 1
                    _ -> 0
                  has_line_multiline = flags == 2 || flags == 3
                  has_next_multiline = has_chain_multiline || has_line_multiline
                  next_multiline = case has_next_multiline of
                    true -> 1
                    _ -> 0
              in format_collect_monadic_chain request_handle source source_len base_indent next (count + 1) next_lambda next_multiline
            _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
        ParsedLine MonadicLineNil _ ->
          let content_end = format_find_comment_boundary request_handle next_i line_end
              has_content = format_has_nonspace request_handle next_i content_end
          in case has_content of
            false -> format_collect_monadic_chain request_handle source source_len base_indent next count has_lambda has_multiline
            _ ->
              let indent = format_leading_space_len request_handle next_i line_end 0
                  has_child_indent = indent > base_indent
              in let child_indent_state =
                   case has_child_indent of
                     true -> 0
                     _ -> 1
                 in case child_indent_state of
                   0 -> format_collect_monadic_chain request_handle source source_len base_indent next count has_lambda has_multiline
                   _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline

format_find_next_chain_operator request_handle source chain_end base_indent next_i =
  case (next_i >= chain_end) of
    true -> chain_end
    _ ->
      let line_end = format_line_end request_handle next_i chain_end
          parsed = format_parse_monadic_line request_handle source next_i line_end
          next = format_next_line_start line_end chain_end
      in case parsed of
        ParsedLine (MonadicLineNode _ _ indent _ _ _ _) _ ->
          let is_sufficient_indent = indent >= base_indent
          in case is_sufficient_indent of
            true -> next_i
            _ -> format_find_next_chain_operator request_handle source chain_end base_indent next
        ParsedLine MonadicLineNil _ ->
          let content_end = format_find_comment_boundary request_handle next_i chain_end
              has_content = format_has_nonspace request_handle next_i content_end
              indent = case has_content of
                true -> format_leading_space_len request_handle next_i chain_end 0
                _ -> 0
              is_next_indent = indent > base_indent
          in let chain_end_state =
               case has_content is_next_indent of
                 false _ -> 0
                 _ true -> 1
                 _ _ -> 2
             in case chain_end_state of
               0 -> format_find_next_chain_operator request_handle source chain_end base_indent next
               _ -> chain_end

format_find_chain_first_body_indent request_handle source body_start body_end op_indent =
  case (body_start >= body_end) of
    true -> -1
    _ ->
      let line_end = format_line_end request_handle body_start body_end
          next = format_next_line_start line_end body_end
          content_end = format_find_comment_boundary request_handle body_start line_end
          has_content = format_has_nonspace request_handle body_start content_end
          indent = format_leading_space_len request_handle body_start line_end 0
          has_body_indent = indent > op_indent
      in let body_indent_state =
           case has_content has_body_indent of
             true true -> 0
             _ _ -> 1
         in case body_indent_state of
              0 -> indent
              _ -> format_find_chain_first_body_indent request_handle source next body_end op_indent

format_copy_chain_body request_handle source out out_i source_end op_indent first_body_indent normalized_body_indent body_start body_end =
  case (body_start >= body_end) of
    true -> out_i
    _ ->
      let line_end = format_line_end request_handle body_start body_end
          next = format_next_line_start line_end body_end
          content_end = format_find_comment_boundary request_handle body_start line_end
          has_content = format_has_nonspace request_handle body_start content_end
          shift = normalized_body_indent - first_body_indent
          line_indent = format_leading_space_len request_handle body_start line_end 0
          has_body_indent = line_indent > op_indent
          copy_body_state = case has_content has_body_indent of
            true false -> 0
            true true -> 1
            _ _ -> 2
          out1 = case copy_body_state of
            0 -> format_copy_raw_line request_handle source body_start line_end out out_i body_end
            1 ->
              format_copy_line_with_indent request_handle source body_start line_end (line_indent + shift) out out_i body_end
            _ -> format_copy_raw_line request_handle source body_start line_end out out_i body_end
      in format_copy_chain_body request_handle source out1 out1 source_end op_indent first_body_indent normalized_body_indent next body_end

format_normalize_chain_region request_handle source source_len out out_i i chain_end base_indent =
  case (i >= chain_end) of
    true -> out_i
    _ ->
      let line_end = format_line_end request_handle i source_len
          next = format_next_line_start line_end source_len
          parsed = format_parse_monadic_line request_handle source i line_end
      in case parsed of
        ParsedLine (MonadicLineNode _ _ op_indent _ _ _ _) _ ->
          let out1 = format_copy_line_with_indent request_handle source i line_end base_indent out out_i source_len
              body_start = next
              next_op = format_find_next_chain_operator request_handle source chain_end base_indent body_start
              first_body_indent = format_find_chain_first_body_indent request_handle source body_start next_op op_indent
              is_missing_body_indent = first_body_indent < 0
              is_body_indent_missing = is_missing_body_indent
          in case is_body_indent_missing of
            true ->
              format_normalize_chain_region request_handle source source_len out1 next_op chain_end base_indent
            _ ->
              let relative_body_indent = max2 1 (first_body_indent - op_indent)
                  normalized_body_indent = base_indent + relative_body_indent
                  out2 = format_copy_chain_body request_handle source out1 source_len op_indent first_body_indent normalized_body_indent body_start next_op
              in format_normalize_chain_region request_handle source source_len out2 next_op chain_end base_indent
        ParsedLine MonadicLineNil _ ->
          format_normalize_chain_region request_handle source source_len out out_i next chain_end base_indent

format_normalize_monadic_lines request_handle source source_len out out_i i =
  case (i >= source_len) of
    true -> out_i
    _ ->
      let line_end = format_line_end request_handle i source_len
          next_i = case (line_end < source_len) of true -> line_end + 1 _ -> line_end
      in case format_parse_monadic_line request_handle source i line_end of
        ParsedLine MonadicLineNil _ ->
          let out1 = format_copy_segment request_handle OwnershipRewriteLinear source i out out_i (line_end - i)
              out2 = case (line_end < source_len) of
                true -> slice_set_u8 request_handle OwnershipRewriteLinear out1 out1 format_newline_byte
                _ -> out1
          in format_normalize_monadic_lines request_handle source source_len out2 next_i
        ParsedLine (MonadicLineNode _ _ base_indent _ _ _ _) flags ->
          let has_first_lambda = flags == 1 || flags == 3
              first_lambda = case has_first_lambda of
                true -> 1
                _ -> 0
              has_first_multiline = flags == 2 || flags == 3
              first_multiline = case has_first_multiline of
                true -> 1
                _ -> 0
              ChainCollect _ chain_end chain_count chain_lambda chain_multiline = format_collect_monadic_chain request_handle source source_len base_indent next_i 1 first_lambda first_multiline
              should_normalize_chain = chain_count >= 2 && chain_lambda == 1 && chain_multiline == 0
              is_normalizable_chain_size = chain_count >= 2
              has_lambda_chain = chain_lambda == 1
              is_one_line = chain_multiline == 0
          in let normalize_chain_state =
               case should_normalize_chain is_normalizable_chain_size has_lambda_chain is_one_line of
                 true true true true -> 0
                 _ _ _ _ -> 1
             in case normalize_chain_state of
               0 ->
                 let out1 = format_normalize_chain_region request_handle source source_len out out_i i chain_end base_indent
                 in format_normalize_monadic_lines request_handle source source_len out1 chain_end
               _ ->
                 let out1 = format_copy_segment request_handle OwnershipRewriteLinear source i out out_i (chain_end - i)
                 in format_normalize_monadic_lines request_handle source source_len out1 chain_end

format_normalize_source request_handle source source_len out out_i =
  let decoded = slice_new_u8 (source_len + 1)
      decoded_len = format_unescape_source_loop request_handle source source_len decoded 0 0
      normalized = slice_new_u8 (decoded_len + format_default_line_width * 8)
      normalized_len = format_normalize_source_lines decoded OwnershipRewriteLinear decoded decoded_len normalized 0 0
      monadic = slice_new_u8 (normalized_len * 2 + format_default_line_width * 4)
      monadic_len = format_normalize_monadic_lines normalized normalized normalized_len monadic 0 0
      out1 = format_copy_segment monadic OwnershipRewriteLinear monadic 0 out out_i monadic_len

find_source_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"source\""

find_input_source_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"input_source\""

find_input_path_start request_handle i req_len =
  find_json_key_value_start request_handle i req_len "\"input_path\""

max_source_scan_steps = 1024
max_inline_request_len = 32768
max_inline_validation_request_len = 2048
find_source_end_scan_chunk = 64

find_source_end request_handle i req_len slash_parity =
  find_source_end_limited request_handle i req_len slash_parity 0

find_source_end_scan_state i slash_parity =
  case (slash_parity == 0) of
    true -> -(i + 1)
    _ -> -((i + 1) + max_inline_request_len)

find_source_end_scan_state_next_i state =
  let payload = -state
  in case (payload > max_inline_request_len) of
    true -> payload - max_inline_request_len - 1
    _ -> payload - 1

find_source_end_scan_state_next_parity state =
  let payload = -state
  in case (payload > max_inline_request_len) of
    true -> 1
    _ -> 0

find_source_end_scan_chunk_limited request_handle i slash_parity chunk_size offset =
  case (offset == chunk_size) of
    true -> find_source_end_scan_state (i + offset) slash_parity
    _ ->
          let at = i + offset
              b = slice_get_u8 request_handle at
              is_backslash = b == format_backslash_byte
              is_quote = b == format_quote_byte
              has_quote_or_escape = is_backslash || is_quote
              is_even_parity = slash_parity == 0
          let quote_state =
                case has_quote_or_escape is_even_parity of
                  true _ -> 0
                  _ true -> 1
                  _ _ -> 2
          in case quote_state of
            0 ->
              find_source_end_scan_chunk_limited
                request_handle
                i
                (1 - slash_parity)
                chunk_size
                (offset + 1)
            1 -> at
            _ ->
              find_source_end_scan_chunk_limited
                request_handle
                i
                0
                chunk_size
                (offset + 1)

find_source_end_limited request_handle i req_len slash_parity steps =
  let is_scan_limit_reached = steps == max_source_scan_steps
  in case is_scan_limit_reached of
    true -> req_len
    _ ->
      let has_invalid_position = (i < 0) || (i >= req_len)
          should_stop_scan = is_scan_limit_reached || has_invalid_position
      in case should_stop_scan of
        true -> req_len
        _ ->
          let remaining = req_len - i
              chunk_size = case (remaining <= find_source_end_scan_chunk) of
                true -> remaining
                _ -> find_source_end_scan_chunk
              scan_state = find_source_end_scan_chunk_limited request_handle i slash_parity chunk_size 0
              has_found_boundary = scan_state >= 0
          in case has_found_boundary of
            true -> scan_state
            _ ->
              let next_i = find_source_end_scan_state_next_i scan_state
                  next_parity = find_source_end_scan_state_next_parity scan_state
              in find_source_end_limited request_handle next_i req_len next_parity (steps + 1)


slice_set_u8_write request_handle ownership_mode target start value =
  slice_set_u8 target start value

copy_slice_segment request_handle ownership_mode src src_start dst dst_start seg_len i = case (i == seg_len) of
  true -> dst
  _ ->
    case (i + 16 <= seg_len) of
      true ->
        let b0 = slice_get_u8 src (src_start + i)
            d0 = slice_set_u8_write request_handle ownership_mode dst (dst_start + i) b0
            b1 = slice_get_u8 src (src_start + i + 1)
            d1 = slice_set_u8_write request_handle ownership_mode d0 (dst_start + i + 1) b1
            b2 = slice_get_u8 src (src_start + i + 2)
            d2 = slice_set_u8_write request_handle ownership_mode d1 (dst_start + i + 2) b2
            b3 = slice_get_u8 src (src_start + i + 3)
            d3 = slice_set_u8_write request_handle ownership_mode d2 (dst_start + i + 3) b3
            b4 = slice_get_u8 src (src_start + i + 4)
            d4 = slice_set_u8_write request_handle ownership_mode d3 (dst_start + i + 4) b4
            b5 = slice_get_u8 src (src_start + i + 5)
            d5 = slice_set_u8_write request_handle ownership_mode d4 (dst_start + i + 5) b5
            b6 = slice_get_u8 src (src_start + i + 6)
            d6 = slice_set_u8_write request_handle ownership_mode d5 (dst_start + i + 6) b6
            b7 = slice_get_u8 src (src_start + i + 7)
            d7 = slice_set_u8_write request_handle ownership_mode d6 (dst_start + i + 7) b7
            b8 = slice_get_u8 src (src_start + i + 8)
            d8 = slice_set_u8_write request_handle ownership_mode d7 (dst_start + i + 8) b8
            b9 = slice_get_u8 src (src_start + i + 9)
            d9 = slice_set_u8_write request_handle ownership_mode d8 (dst_start + i + 9) b9
            b10 = slice_get_u8 src (src_start + i + 10)
            d10 = slice_set_u8_write request_handle ownership_mode d9 (dst_start + i + 10) b10
            b11 = slice_get_u8 src (src_start + i + 11)
            d11 = slice_set_u8_write request_handle ownership_mode d10 (dst_start + i + 11) b11
            b12 = slice_get_u8 src (src_start + i + 12)
            d12 = slice_set_u8_write request_handle ownership_mode d11 (dst_start + i + 12) b12
            b13 = slice_get_u8 src (src_start + i + 13)
            d13 = slice_set_u8_write request_handle ownership_mode d12 (dst_start + i + 13) b13
            b14 = slice_get_u8 src (src_start + i + 14)
            d14 = slice_set_u8_write request_handle ownership_mode d13 (dst_start + i + 14) b14
            b15 = slice_get_u8 src (src_start + i + 15)
            d15 = slice_set_u8_write request_handle ownership_mode d14 (dst_start + i + 15) b15
        in copy_slice_segment request_handle ownership_mode src src_start d15 dst_start seg_len (i + 16)
      _ ->
        let b = slice_get_u8 src (src_start + i)
            next = slice_set_u8_write request_handle ownership_mode dst (dst_start + i) b
        in copy_slice_segment request_handle ownership_mode src src_start next dst_start seg_len (i + 1)

json_escape_extra_len src start seg_len i extra = case (i == seg_len) of
  true -> extra
  _ ->
      let b = slice_get_u8 src (start + i)
          is_quote = b == format_quote_byte
          is_backslash = b == format_backslash_byte
          is_newline = b == format_newline_byte
          is_carriage = b == format_carriage_return_byte
      is_tab = b == format_tab_byte
      needs_escape = is_quote || is_backslash || is_newline || is_carriage || is_tab
    in case needs_escape of
      true -> json_escape_extra_len src start seg_len (i + 1) (extra + 1)
      _ -> json_escape_extra_len src start seg_len (i + 1) extra

json_copy_escaped_segment request_handle ownership_mode src start seg_len i dst dst_i = case (i == seg_len) of
  true -> dst
  _ ->
  let b = slice_get_u8 src (start + i)
      is_quote = b == format_quote_byte
      is_backslash = b == format_backslash_byte
      is_newline = b == format_newline_byte
      is_carriage = b == format_carriage_return_byte
      is_tab = b == format_tab_byte
      needs_escape = is_quote || is_backslash || is_newline || is_carriage || is_tab
      in case needs_escape of
        true ->
        let escaped_state =
              case is_quote is_backslash is_newline is_carriage is_tab of
                true _ _ _ _ -> 0
                _ true _ _ _ -> 1
                _ _ true _ _ -> 2
                _ _ _ true _ -> 3
                _ _ _ _ true -> 4
                _ _ _ _ _ -> 5
            escaped_byte = case escaped_state of
              0 -> format_quote_byte
              1 -> format_backslash_byte
              2 -> format_escape_n_byte
              3 -> format_escape_r_byte
              4 -> format_escape_t_byte
              _ -> format_backslash_byte
        in
        let d1 = slice_set_u8_write request_handle ownership_mode dst dst_i format_backslash_byte
            d2 = slice_set_u8_write request_handle ownership_mode d1 (dst_i + 1) escaped_byte
        in json_copy_escaped_segment request_handle ownership_mode src start seg_len (i + 1) d2 (dst_i + 2)
      _ ->
        let d1 = slice_set_u8_write request_handle ownership_mode dst dst_i b
        in json_copy_escaped_segment request_handle ownership_mode src start seg_len (i + 1) d1 (dst_i + 1)

json_slice_end request_handle source_start req_len =
  let source_end_raw = find_source_end request_handle source_start req_len 0
      is_shorter_than_start = source_end_raw < source_start
      is_longer_than_end = source_end_raw > req_len
      source_end_state =
        case is_shorter_than_start is_longer_than_end of
          true _ -> 0
          _ true -> 1
          _ _ -> 2
  in case source_end_state of
       0 -> source_start
       1 -> req_len
       _ -> source_end_raw

json_response_with_literal_prefix_suffix request_handle ownership_mode prefix suffix =
  let prefix_len = slice_len prefix
      suffix_len = slice_len suffix
      out = slice_new_u8 (prefix_len + suffix_len)
      out1 = copy_slice_literal request_handle ownership_mode out 0 prefix
  in copy_slice_literal request_handle ownership_mode out1 prefix_len suffix

json_response_with_slice_segment request_handle ownership_mode prefix suffix src src_start src_len =
  let prefix_len = slice_len prefix
      suffix_len = slice_len suffix
      total_len = prefix_len + src_len + suffix_len
      out = slice_new_u8 total_len
      out1 = copy_slice_literal request_handle ownership_mode out 0 prefix
      out2 = copy_slice_segment request_handle ownership_mode src src_start out1 prefix_len src_len 0
  in copy_slice_literal request_handle ownership_mode out2 (prefix_len + src_len) suffix

json_response_with_escaped_slice_segment request_handle ownership_mode prefix suffix src src_start src_len =
  let prefix_len = slice_len prefix
      escaped_extra = json_escape_extra_len src src_start src_len 0 0
      escaped_len = src_len + escaped_extra
      suffix_len = slice_len suffix
      total_len = prefix_len + escaped_len + suffix_len
      out = slice_new_u8 total_len
      out1 = copy_slice_literal request_handle ownership_mode out 0 prefix
      out2 = json_copy_escaped_segment request_handle ownership_mode src src_start src_len 0 out1 prefix_len
  in copy_slice_literal request_handle ownership_mode out2 (prefix_len + escaped_len) suffix

json_response_from_slice request_handle ownership_mode literal =
  let out = slice_new_u8 (slice_len literal)
      out1 = copy_slice_literal request_handle ownership_mode out 0 literal
  in out1

format_empty_response request_handle ownership_mode =
  json_response_with_literal_prefix_suffix request_handle ownership_mode json_format_prefix json_format_suffix

format_source_response request_handle ownership_mode source_start req_len =
  let source_end = json_slice_end request_handle source_start req_len
      source_len = source_end - source_start
      formatted = slice_new_u8 (source_len * 2 + format_default_line_width * 8)
      formatted_len = format_normalize_source request_handle source_start source_len formatted 0
  in json_response_with_escaped_slice_segment
    request_handle
    ownership_mode
    json_format_prefix
    json_format_suffix
    formatted
    0
    formatted_len

format_ok_response request_handle ownership_mode =
  let req_len = slice_len request_handle
      source_start = find_source_start request_handle 0 req_len
  in case (source_start == req_len) of
    true -> format_empty_response request_handle ownership_mode
    _ -> format_source_response request_handle ownership_mode source_start req_len
