module compiler.formatter
import compiler.prelude
import compiler.scan
import compiler.json_response
export format_ok_response

data OwnershipRewriteMode = OwnershipRewriteLinear | OwnershipRewriteCopyOnWrite
data MonadicLine = MonadicLineNil
  | MonadicLineNode
    Int
    Int
    Int
    Int
    Int
    Int
    MonadicLine
data ParsedLine = ParsedLine MonadicLine Int
data ChainCollect = ChainCollect MonadicLine Int Int Int Int
data FormatNonProgressError =
  FormatNonProgressChainRegion
  | FormatNonProgressCopyChainBody
  | FormatNonProgressNormalizeMonadicLines
data FormatNormalizeResult =
  FormatNormalizeOk Int
  | FormatNormalizeError FormatNonProgressError

json_format_prefix = str_to_slice "{\"ok\":true,\"formatted\":\""
json_format_suffix = str_to_slice "\"}"


is_space_byte b =
  let is_space_32 = (b == format_space_byte)
      is_space_9 = (b == format_tab_byte)
      is_space_10 = (b == format_newline_byte)
      is_space_13 = (b == format_carriage_return_byte)
  in is_space_32 || is_space_9 || is_space_10 || is_space_13

max2 a b = case (a > b) of
  true -> a
  _ -> b

format_default_line_width = 100
format_continuation_spaces = 2
format_newline_byte = byte '\n'
format_carriage_return_byte = byte '\r'
format_space_byte = byte ' '
format_tab_byte = byte '\t'
format_quote_byte = char '"'
format_escape_byte = char '\\'
format_backslash_byte = char '\\'
format_dash_byte = char '-'
format_form_feed_byte = char '\f'
format_backspace_byte = char '\b'
format_slash_byte = char '/'
format_eq_byte = char '='
format_gt_byte = char '>'
format_amp_byte = char '&'
format_bar_byte = char '|'
format_escape_n_byte = char 'n'
format_escape_r_byte = char 'r'
format_escape_t_byte = char 't'
format_escape_b_byte = char 'b'
format_escape_f_byte = char 'f'
format_is_space_or_tab b = (b == format_space_byte) || (b == format_tab_byte)

format_unescape_source_loop request_handle source_start source_end out out_i i =
  case (source_start + i >= source_end) of
    true -> out_i
    _ ->
      let b = slice_get_u8 request_handle (source_start + i)
      in case (b == format_escape_byte) of
        true ->
          case (source_start + i + 1 >= source_end) of
            true ->
              let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i b
              in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 1)
            _ ->
              let e = slice_get_u8 request_handle (source_start + i + 1)
              in case e of
                format_quote_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_quote_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_backslash_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_escape_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_n_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_newline_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_r_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_carriage_return_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_t_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_tab_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_b_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_backspace_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_escape_f_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_form_feed_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                format_slash_byte ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i format_slash_byte
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
                _ ->
                  let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i e
                  in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 2)
        _ ->
          let next = slice_set_u8 request_handle OwnershipRewriteLinear out out_i b
          in format_unescape_source_loop request_handle source_start source_end next (out_i + 1) (i + 1)

format_find_comment_start_loop request_handle line_start line_end i in_string escaped =
  case (line_start + i >= line_end) of
    true -> Nothing
    _ ->
      let at = line_start + i
          b = slice_get_u8 request_handle at
          is_quote = b == format_quote_byte
          is_escape = b == format_escape_byte
          is_dash = b == format_dash_byte
          is_comment = is_dash && (at + 1 < line_end) && (slice_get_u8 request_handle (at + 1) == format_dash_byte)
      in case in_string of
        true ->
          case escaped of
            true -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true false
            _ ->
              case is_escape of
                true -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true true
                _ ->
                  case is_quote of
                    true -> format_find_comment_start_loop request_handle line_start line_end (i + 1) false false
                    _ -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true false
        _ ->
          case is_quote of
            true -> format_find_comment_start_loop request_handle line_start line_end (i + 1) true false
            _ ->
              case is_comment of
                true -> Just at
                _ -> format_find_comment_start_loop request_handle line_start line_end (i + 1) false false

format_find_comment_start request_handle line_start line_end =
  format_find_comment_start_loop request_handle line_start line_end 0 false false

format_leading_space_len request_handle line_start line_end i =
  case (line_start + i >= line_end) of
    true -> i
    _ ->
      case format_is_space_or_tab (slice_get_u8 request_handle (line_start + i)) of
        true -> format_leading_space_len request_handle line_start line_end (i + 1)
        _ -> i

format_trim_trailing_spaces request_handle scratch start i =
  case (i <= start) of
    true -> i
    _ ->
      let at = i - 1
      in case format_is_space_or_tab (slice_get_u8 request_handle at) of
        true -> format_trim_trailing_spaces request_handle scratch start (i - 1)
        _ -> i

format_collapse_code request_handle ownership_mode source start end scratch out_i i in_string escaped prev_space =
  case (start + i >= end) of
    true -> out_i
    _ ->
      let b = slice_get_u8 request_handle (start + i)
          is_escape = b == format_escape_byte
          is_quote = b == format_quote_byte
          is_space = format_is_space_or_tab b
          is_space_or_start = prev_space || (out_i == 0)
          next_char = slice_set_u8 request_handle ownership_mode scratch out_i b
          is_string_escape = in_string && escaped
          is_string_escape_char = in_string && !escaped && is_escape
          is_string_quote = in_string && !escaped && is_quote
          is_string_data = in_string && !escaped && !is_escape && !is_quote && !is_space
          is_space_outside = !in_string && is_space
          is_space_at_segment_start = is_space_outside && is_space_or_start
      let collapse_state =
            case is_string_escape of
              true -> 0
              _ ->
                case is_string_escape_char of
                  true -> 1
                  _ ->
                    case is_string_quote of
                      true -> 2
                      _ ->
                        case is_string_data of
                          true -> 3
                          _ ->
                            case is_space_at_segment_start of
                              true -> 4
                              _ ->
                                case is_space_outside of
                                  true -> 5
                                  _ -> 6
      in case collapse_state of
        0 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true false prev_space
        1 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true true prev_space
        2 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) false false prev_space
        3 ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) true false prev_space
        4 ->
          format_collapse_code request_handle ownership_mode source start end scratch out_i (i + 1) false false true
        5 ->
          let next_space = slice_set_u8 request_handle ownership_mode scratch out_i format_space_byte
          in format_collapse_code request_handle ownership_mode source start end next_space (out_i + 1) (i + 1) false false true
        _ ->
          format_collapse_code request_handle ownership_mode source start end next_char (out_i + 1) (i + 1) false false false

format_normalize_line request_handle ownership_mode source line_start line_end scratch =
  let comment_start = format_find_comment_start request_handle line_start line_end
      code_end = maybe_with_default line_end comment_start
      indent_len = format_leading_space_len request_handle line_start code_end 0
      compact_end = format_collapse_code request_handle ownership_mode source (line_start + indent_len) code_end scratch indent_len 0 false false false
      compact_trim = format_trim_trailing_spaces request_handle scratch compact_end compact_end
      copied_prefix = copy_slice_segment request_handle source line_start scratch 0 indent_len 0
      comment_len = maybe_with_default 0
        (maybe_map
          (\at ->
            let len = line_end - at
            in copy_slice_segment request_handle source at copied_prefix compact_trim len 0
               in len)
          comment_start)
  in compact_trim + comment_len

format_copy_spaces request_handle ownership_mode out out_i count =
  case (count <= 0) of
    true -> out_i
    _ ->
      let next = slice_set_u8 request_handle ownership_mode out out_i format_space_byte
      in format_copy_spaces request_handle ownership_mode out (out_i + 1) (count - 1)

format_find_wrap_token_loop request_handle source start len width i in_string escaped best =
  case (i > width || i >= len) of
    true -> best
    _ ->
      let at = start + i
          b = slice_get_u8 request_handle at
          max_i = len
          is_quote = b == format_quote_byte
          is_escape = b == format_escape_byte
      in case in_string of
        true ->
          case escaped of
            true -> format_find_wrap_token_loop request_handle source start len width (i + 1) true false best
            _ ->
              case is_escape of
                true -> format_find_wrap_token_loop request_handle source start len width (i + 1) true true best
                _ ->
                  case is_quote of
                    true -> format_find_wrap_token_loop request_handle source start len width (i + 1) false false best
                    _ -> format_find_wrap_token_loop request_handle source start len width (i + 1) true false best
        _ ->
          case is_quote of
            true -> format_find_wrap_token_loop request_handle source start len width (i + 1) true false best
            _ ->
              let has_space = (b == format_space_byte)
                  token1 =
                    has_space
                    && (i + 3 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_eq_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_space_byte)
                  token2 =
                    has_space
                    && (i + 2 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_eq_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_space_byte)
                  token3 =
                    has_space
                    && (i + 3 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_dash_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_space_byte)
                  token4 =
                    has_space
                    && (i + 5 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_eq_byte)
                    && (slice_get_u8 request_handle (at + 4) == format_space_byte)
                  token5 =
                    has_space
                    && (i + 3 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_gt_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_space_byte)
                  token6 =
                    has_space
                    && (i + 3 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_amp_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_amp_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_space_byte)
                  token7 =
                    has_space
                    && (i + 3 <= max_i)
                    && (slice_get_u8 request_handle (at + 1) == format_bar_byte)
                    && (slice_get_u8 request_handle (at + 2) == format_bar_byte)
                    && (slice_get_u8 request_handle (at + 3) == format_space_byte)
                  has_wrap_token = token1 || token2 || token3 || token4 || token5 || token6 || token7
              in case has_wrap_token of
                true -> format_find_wrap_token_loop request_handle source start len width (i + 1) false false (Just i)
                _ -> format_find_wrap_token_loop request_handle source start len width (i + 1) false false best

format_find_wrap_break request_handle line start len width =
  let token = format_find_wrap_token_loop request_handle line start len width 0 false false Nothing
    in case token of
      Just i -> Just i
      _ -> format_find_wrap_whitespace request_handle line start len width

format_find_wrap_whitespace request_handle source start len width =
  case (width <= 0) of
    true -> Nothing
    _ ->
      let scan i best in_string escaped =
        case (i >= width || i >= len) of
          true -> best
          _ ->
            let at = start + i
                b = slice_get_u8 request_handle at
                is_quote = b == format_quote_byte
                is_escape = b == format_escape_byte
                is_space = format_is_space_or_tab b
            in case in_string of
              true ->
                case escaped of
                  true -> scan (i + 1) best true false
                  _ ->
                    case is_escape of
                      true -> scan (i + 1) best true true
                      _ ->
                        case is_quote of
                          true -> scan (i + 1) best false false
                          _ -> scan (i + 1) best true false
              _ ->
                case is_quote of
                  true -> scan (i + 1) best true false
                  _ ->
                    case is_space of
                      true -> scan (i + 1) (Just i) false false
                      _ -> scan (i + 1) best false false
      in scan 0 Nothing false false

format_emit_wrap_prefix request_handle ownership_mode line base_indent_len is_cont out out_i =
  let out1 = copy_slice_segment request_handle ownership_mode line 0 out out_i base_indent_len 0
  in case is_cont of
    true -> format_copy_spaces request_handle ownership_mode out1 (out_i + base_indent_len) format_continuation_spaces
    _ -> out_i + base_indent_len

format_copy_segment request_handle ownership_mode source source_start out out_i segment_len =
  case (segment_len <= 0) of
    true -> out_i
    _ ->
      copy_slice_segment request_handle ownership_mode source source_start out out_i segment_len 0
      out_i + segment_len

format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len source_start source_len out out_i has_more is_cont =
  let is_empty = source_len <= 0
  in let wrap_state =
         case is_empty has_more of
           true true -> 0
           true false -> 1
           _ -> 2
     in case wrap_state of
       0 -> slice_set_u8 request_handle ownership_mode out out_i format_newline_byte
       1 -> out_i
       _ ->
          let avail = case is_cont of
            true -> max2 1 (format_default_line_width - (base_indent_len + format_continuation_spaces))
            _ -> max2 1 (format_default_line_width - base_indent_len)
          first_break = format_find_wrap_break request_handle line source_start source_len avail
          has_empty_break = case first_break of
            Just i -> i <= 0
            _ -> true
          raw_chunk_len = case has_empty_break of
            true -> avail
            _ -> maybe_with_default 0 first_break
          chunk_len = case (raw_chunk_len <= 0 || raw_chunk_len > source_len) of
            true -> max2 1 source_len
            _ -> raw_chunk_len
          out1 = format_emit_wrap_prefix request_handle ownership_mode line base_indent_len is_cont out out_i
          out2 = format_copy_segment request_handle ownership_mode line source_start out out1 chunk_len
          is_last_chunk = source_len <= chunk_len
      in let next_source_len = source_len - chunk_len
         last_chunk_state =
           case is_last_chunk has_more of
             true true -> 0
             true false -> 1
             _ -> 2
         in case last_chunk_state of
           0 -> slice_set_u8 request_handle ownership_mode out out2 format_newline_byte
           1 -> out2
           _ ->
             let out3 = slice_set_u8 request_handle ownership_mode out out2 format_newline_byte
             in case (next_source_len < 0 || chunk_len <= 0 || next_source_len == source_len) of
               true -> out3
               _ -> format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len (source_start + chunk_len) next_source_len out out3 true true

format_wrap_line request_handle ownership_mode line line_len base_indent_len out out_i has_more =
  let source_len = case (line_len <= base_indent_len) of
    true -> 0
    _ -> line_len - base_indent_len
  in format_wrap_line_loop request_handle ownership_mode line line_len base_indent_len base_indent_len source_len out out_i has_more false

format_line_end request_handle i end =
  case (i >= end) of
    true -> end
    _ ->
      let b = slice_get_u8 request_handle i
      in case (b == format_newline_byte) of
        true -> i
        _ -> format_line_end request_handle (i + 1) end

format_normalize_source_lines request_handle ownership_mode source source_len out out_i i =
  case (i >= source_len) of
    true -> out_i
    _ ->
      let line_end = format_line_end request_handle i source_len
          has_carriage_return = line_end > i && slice_get_u8 request_handle (line_end - 1) == format_carriage_return_byte
          content_end = case has_carriage_return of
            true -> line_end - 1
            _ -> line_end
          line_len = content_end - i
          use_raw_line = line_len > format_long_line_scan_limit
          scratch = slice_new_u8 (line_len + format_default_line_width + 8)
          scratch_len = case use_raw_line of
            true -> format_copy_segment request_handle ownership_mode source i scratch 0 line_len
            _ -> format_normalize_line request_handle ownership_mode source i content_end scratch
          content_start = format_leading_space_len request_handle 0 scratch_len 0
          has_next_line = line_end < source_len
          is_empty_line = line_len <= 0
          out1 =
            let empty_line_state =
              case is_empty_line has_next_line of
                true true -> 0
                true false -> 1
                _ -> 2
            in case empty_line_state of
              0 -> slice_set_u8 request_handle ownership_mode out out_i format_newline_byte
              1 -> out_i
              _ -> format_wrap_line request_handle ownership_mode scratch scratch_len content_start out out_i has_next_line
          next_i = case has_next_line of
            true -> line_end + 1
            _ -> line_end
      in format_normalize_source_lines request_handle ownership_mode source source_len out out1 next_i

format_skip_spaces request_handle i end =
  case (i >= end) of
    true -> i
    _ ->
      let b = slice_get_u8 request_handle i
      in case (format_is_space_or_tab b) of
        true -> format_skip_spaces request_handle (i + 1) end
        _ -> i

format_trim_right request_handle i start =
  case (i <= start) of
    true -> start
    _ ->
      let at = i - 1
      in case (format_is_space_or_tab (slice_get_u8 request_handle at)) of
        true -> format_trim_right request_handle at start
        _ -> i

format_has_nonspace request_handle i end =
  case (i >= end) of
    true -> false
    _ ->
      let b = slice_get_u8 request_handle i
      in case (format_is_space_or_tab b) of
        true -> format_has_nonspace request_handle (i + 1) end
        _ -> true

format_find_comment_boundary request_handle line_start line_end =
  let comment_start = format_find_comment_start request_handle line_start line_end
  in maybe_with_default line_end comment_start

format_has_content_outside_comment request_handle line_start line_end =
  let content_end = format_find_comment_boundary request_handle line_start line_end
  in format_has_nonspace request_handle line_start content_end

format_has_backslash_arrow request_handle start end =
  case (start >= end) of
    true -> false
    _ ->
      let b = slice_get_u8 request_handle start
      in case (b == format_backslash_byte) of
        true ->
          let next = case (start + 1 < end) of
            true -> start + 1
            _ -> end
          in format_has_arrow request_handle next end
        _ -> format_has_backslash_arrow request_handle (start + 1) end

format_has_arrow request_handle start end =
  case (start + 1 >= end) of
    true -> false
    _ ->
      let is_dash = slice_get_u8 request_handle start == format_dash_byte
          is_arrow = (slice_get_u8 request_handle (start + 1)) == format_gt_byte
      in let has_dash_arrow =
           is_dash && is_arrow
         in case has_dash_arrow of
              true -> true
              _ -> format_has_arrow request_handle (start + 1) end

format_find_monadic_operator request_handle source start end i in_string escaped =
  let at = start + i
  in case (at >= end) of
    true -> Nothing
    _ ->
      let b = slice_get_u8 request_handle at
          is_escape = b == format_escape_byte
          is_quote = b == format_quote_byte
          is_string_escape = in_string && escaped
          is_string_escape_char = in_string && !escaped && is_escape
          is_string_quote = in_string && !escaped && is_quote
      in let monadic_operator_state =
            case is_string_escape is_string_escape_char is_string_quote is_quote of
              true _ _ _ -> 0
              _ true _ _ -> 1
              _ _ true _ -> 2
              _ _ _ true -> 3
              _ _ _ _ -> 4
         in case monadic_operator_state of
           0 -> format_find_monadic_operator request_handle source start end (i + 1) false false
           1 -> format_find_monadic_operator request_handle source start end (i + 1) true true
           2 -> format_find_monadic_operator request_handle source start end (i + 1) false false
           3 -> format_find_monadic_operator request_handle source start end (i + 1) true false
           _ ->
             let is_bind3 =
                (at + 2 < end)
                && (b == format_gt_byte)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
                && (slice_get_u8 request_handle (at + 2) == format_eq_byte)
              is_bind2 =
                (at + 1 < end)
                && (b == format_gt_byte)
                && (slice_get_u8 request_handle (at + 1) == format_gt_byte)
             in case (is_bind3 || is_bind2) of
               true -> Just at
               _ -> format_find_monadic_operator request_handle source start end (i + 1) false false

format_monadic_operator_length request_handle source op_start end =
  case (op_start + 3 < end) of
    true ->
      let has_bind_3_bytes =
        (slice_get_u8 request_handle op_start == format_gt_byte)
        && (slice_get_u8 request_handle (op_start + 1) == format_gt_byte)
        && (slice_get_u8 request_handle (op_start + 2) == format_eq_byte)
      in case has_bind_3_bytes of
        true -> 3
        _ -> 2
    _ -> 2

format_parse_monadic_line request_handle source line_start line_end =
  let line_len = line_end - line_start
      is_line_too_long = line_len > format_long_line_scan_limit
  in case is_line_too_long of
    true -> ParsedLine MonadicLineNil 0
    _ ->
      let content_end = format_find_comment_boundary request_handle line_start line_end
      has_content = format_has_nonspace request_handle line_start content_end
      in case has_content of
        false -> ParsedLine MonadicLineNil 0
        _ ->
          let indent = format_leading_space_len request_handle line_start line_end 0
              op_pos = format_find_monadic_operator request_handle source line_start content_end 0 false false
          in case op_pos of
            Nothing -> ParsedLine MonadicLineNil 0
            Just op_pos ->
              let op_len = format_monadic_operator_length request_handle source op_pos content_end
                  rest_start = format_skip_spaces request_handle (op_pos + op_len) content_end
                  rest_end = format_trim_right request_handle content_end rest_start
                  has_lambda = case (rest_start < rest_end) of
                    true -> format_has_backslash_arrow request_handle rest_start rest_end
                    _ -> false
                  has_rest = rest_start < rest_end
                  is_multiline =
                    has_rest
                    && (rest_end - rest_start > 1)
                    && (slice_get_u8 request_handle rest_start == format_backslash_byte)
                    && (slice_get_u8 request_handle (rest_end - 2) == format_dash_byte)
                    && (slice_get_u8 request_handle (rest_end - 1) == format_gt_byte)
                  has_lambda_flag = case has_lambda of
                    true -> 1
                    _ -> 0
                  is_multiline_flag = case is_multiline of
                    true -> 2
                    _ -> 0
                  flags =
                    has_lambda_flag + is_multiline_flag
                  in ParsedLine (MonadicLineNode line_start line_end indent op_pos op_len rest_start MonadicLineNil) flags

format_monadic_indent node =
  case node of
    MonadicLineNode _ _ indent _ _ _ _ -> indent
    _ -> 0

format_copy_raw_line request_handle source line_start line_end out out_i source_end =
  let out1 = format_copy_segment request_handle OwnershipRewriteLinear source line_start out out_i (line_end - line_start)
  in case (line_end < source_end) of
    true -> slice_set_u8 request_handle OwnershipRewriteLinear out out1 format_newline_byte
    _ -> out1

format_copy_line_with_indent request_handle source line_start line_end indent out out_i source_end =
  let trimmed = format_leading_space_len request_handle line_start line_end 0
      line_len = line_end - line_start
      body_start = line_start + trimmed
      body_len = line_len - trimmed
      out1 = format_copy_spaces request_handle OwnershipRewriteLinear out out_i indent
      out2 = format_copy_segment request_handle OwnershipRewriteLinear source body_start out out1 body_len
      out3 = case (line_end < source_end) of
        true -> slice_set_u8 request_handle OwnershipRewriteLinear out out2 format_newline_byte
        _ -> out2
  in out3

format_next_line_start line_end source_end =
  case (line_end < source_end) of
    true -> line_end + 1
    _ -> line_end

format_collect_monadic_chain request_handle source source_len base_indent next_i count has_lambda has_multiline =
  case (next_i >= source_len) of
    true -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
    _ ->
      let line_end = format_line_end request_handle next_i source_len
          parsed = format_parse_monadic_line request_handle source next_i line_end
          next = format_next_line_start line_end source_len
      in case parsed of
        ParsedLine (MonadicLineNode _ _ indent _ _ _ _) flags ->
          let has_sufficient_indent = indent >= base_indent
          in case has_sufficient_indent of
            true ->
              let has_line_lambda = flags == 1 || flags == 3
                  has_chain_lambda = has_lambda == 1
                  has_chain_multiline = has_multiline == 1
                  has_next_lambda = has_chain_lambda || has_line_lambda
                  next_lambda = case has_next_lambda of
                    true -> 1
                    _ -> 0
                  has_line_multiline = flags == 2 || flags == 3
                  has_next_multiline = has_chain_multiline || has_line_multiline
                  next_multiline = case has_next_multiline of
                    true -> 1
                    _ -> 0
                  has_progress = next > next_i
              in case has_progress of
                true -> format_collect_monadic_chain request_handle source source_len base_indent next (count + 1) next_lambda next_multiline
                _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
            _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
        ParsedLine MonadicLineNil _ ->
          let content_end = format_find_comment_boundary request_handle next_i line_end
              has_content = format_has_nonspace request_handle next_i content_end
          in case has_content of
            false -> format_collect_monadic_chain request_handle source source_len base_indent next count has_lambda has_multiline
            _ ->
              let indent = format_leading_space_len request_handle next_i line_end 0
                  has_child_indent = indent > base_indent
              in let child_indent_state =
                   case has_child_indent of
                     true -> 0
                     _ -> 1
                 in case child_indent_state of
                   0 ->
                     let has_progress = next > next_i
                     in case has_progress of
                       true -> format_collect_monadic_chain request_handle source source_len base_indent next count has_lambda has_multiline
                       _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline
                   _ -> ChainCollect MonadicLineNil next_i count has_lambda has_multiline

format_find_next_chain_operator request_handle source chain_end base_indent next_i =
  case (next_i >= chain_end) of
    true -> chain_end
    _ ->
      let line_end = format_line_end request_handle next_i chain_end
          parsed = format_parse_monadic_line request_handle source next_i line_end
          next = format_next_line_start line_end chain_end
      in case parsed of
        ParsedLine (MonadicLineNode _ _ indent _ _ _ _) _ ->
          let is_sufficient_indent = indent >= base_indent
          in case is_sufficient_indent of
            true -> next_i
            _ ->
              let has_progress = next > next_i
              in case has_progress of
                true -> format_find_next_chain_operator request_handle source chain_end base_indent next
                _ -> chain_end
        ParsedLine MonadicLineNil _ ->
          let content_end = format_find_comment_boundary request_handle next_i chain_end
              has_content = format_has_nonspace request_handle next_i content_end
              indent = case has_content of
                true -> format_leading_space_len request_handle next_i chain_end 0
                _ -> 0
              is_next_indent = indent > base_indent
          in let chain_end_state =
               case has_content is_next_indent of
                 false _ -> 0
                 _ true -> 1
                 _ _ -> 2
             in case chain_end_state of
               0 ->
                 let has_progress = next > next_i
                 in case has_progress of
                   true -> format_find_next_chain_operator request_handle source chain_end base_indent next
                   _ -> chain_end
               _ -> chain_end

format_find_chain_first_body_indent request_handle source body_start body_end op_indent =
  case (body_start >= body_end) of
    true -> Nothing
    _ ->
      let line_end = format_line_end request_handle body_start body_end
          next = format_next_line_start line_end body_end
          content_end = format_find_comment_boundary request_handle body_start line_end
          has_content = format_has_nonspace request_handle body_start content_end
          indent = format_leading_space_len request_handle body_start line_end 0
          has_body_indent = indent > op_indent
      in let body_indent_state =
           case has_content has_body_indent of
             true true -> 0
             _ _ -> 1
         in case body_indent_state of
              0 -> Just indent
              _ ->
                let has_progress = next > body_start
                in case has_progress of
                  true -> format_find_chain_first_body_indent request_handle source next body_end op_indent
                  _ -> Nothing

format_copy_chain_body request_handle source out out_i source_end op_indent first_body_indent normalized_body_indent body_start body_end =
  format_copy_chain_body_with_budget
    request_handle
    source
    out
    out_i
    source_end
    op_indent
    first_body_indent
    normalized_body_indent
    body_start
    body_end
    format_nonprogress_guard_limit

format_copy_chain_body_with_budget request_handle source out out_i source_end op_indent first_body_indent normalized_body_indent body_start body_end budget =
  case (budget <= 0) of
    true -> FormatNormalizeError FormatNonProgressCopyChainBody
    _ ->
      case (body_start >= body_end) of
        true -> FormatNormalizeOk out_i
        _ ->
          let line_end = format_line_end request_handle body_start body_end
              next = format_next_line_start line_end body_end
              content_end = format_find_comment_boundary request_handle body_start line_end
              has_content = format_has_nonspace request_handle body_start content_end
              shift = normalized_body_indent - first_body_indent
              line_indent = format_leading_space_len request_handle body_start line_end 0
              has_body_indent = line_indent > op_indent
              copy_body_state = case has_content has_body_indent of
                true false -> 0
                true true -> 1
                _ _ -> 2
              out1 = case copy_body_state of
                0 -> format_copy_raw_line request_handle source body_start line_end out out_i body_end
                1 ->
                  format_copy_line_with_indent request_handle source body_start line_end (line_indent + shift) out out_i body_end
                _ -> format_copy_raw_line request_handle source body_start line_end out out_i body_end
              has_progress = next > body_start
          in case has_progress of
            true ->
              case (out1 < 0) of
                true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                _ ->
                  let out2 = format_copy_chain_body_with_budget
                    request_handle
                    source
                    out
                    out1
                    source_end
                    op_indent
                    first_body_indent
                    normalized_body_indent
                    next
                    body_end
                    (budget - 1)
                  in case out2 of
                    FormatNormalizeError err -> FormatNormalizeError err
                    FormatNormalizeOk out2_i -> FormatNormalizeOk out2_i
            _ ->
              case (out1 < 0) of
                true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                _ -> FormatNormalizeOk out1

format_normalize_chain_region request_handle source source_len out out_i i chain_end base_indent =
  format_normalize_chain_region_with_budget
    request_handle
    source
    source_len
    out
    out_i
    i
    chain_end
    base_indent
    format_nonprogress_guard_limit

format_normalize_chain_region_with_budget request_handle source source_len out out_i i chain_end base_indent budget =
  case (budget <= 0) of
    true -> FormatNormalizeError FormatNonProgressChainRegion
    _ ->
      case (i >= chain_end) of
        true -> FormatNormalizeOk out_i
        _ ->
          let line_end = format_line_end request_handle i source_len
              next = format_next_line_start line_end source_len
              parsed = format_parse_monadic_line request_handle source i line_end
          in case parsed of
            ParsedLine (MonadicLineNode _ _ op_indent _ _ _ _) _ ->
              let out1 = format_copy_line_with_indent request_handle source i line_end base_indent out out_i source_len
                  body_start = next
                  next_op = format_find_next_chain_operator request_handle source chain_end base_indent body_start
                  first_body_indent = format_find_chain_first_body_indent request_handle source body_start next_op op_indent
                  has_next_progress = next_op > body_start && next_op <= chain_end
              in case has_next_progress of
                false ->
                  case (out1 < 0) of
                    true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                    _ -> FormatNormalizeOk out1
                _ ->
                  case first_body_indent of
                    Nothing ->
                      let out2 = format_normalize_chain_region_with_budget
                          request_handle
                          source
                          source_len
                          out
                          out1
                          next_op
                          chain_end
                          base_indent
                          (budget - 1)
                      in case out2 of
                        FormatNormalizeError err -> FormatNormalizeError err
                        FormatNormalizeOk out2_i -> FormatNormalizeOk out2_i
                    Just first_body_indent ->
                      let relative_body_indent = max2 1 (first_body_indent - op_indent)
                          normalized_body_indent = base_indent + relative_body_indent
                          out2 = format_copy_chain_body_with_budget
                            request_handle
                            source
                            out
                            out1
                            source_len
                            op_indent
                            first_body_indent
                            normalized_body_indent
                            body_start
                            next_op
                            (budget - 1)
                      in case out2 of
                        FormatNormalizeError err -> FormatNormalizeError err
                        FormatNormalizeOk out2_i ->
                          format_normalize_chain_region_with_budget
                            request_handle
                            source
                            source_len
                            out
                            out2_i
                            next_op
                            chain_end
                            base_indent
                            (budget - 1)
            ParsedLine MonadicLineNil _ ->
              format_normalize_chain_region_with_budget
                request_handle
                source
                source_len
                out
                out_i
                next
                chain_end
                base_indent
                (budget - 1)

format_normalize_monadic_lines request_handle source source_len out out_i i =
  format_normalize_monadic_lines_with_budget
    request_handle
    source
    source_len
    out
    out_i
    i
    format_nonprogress_guard_limit

format_normalize_monadic_lines_with_budget request_handle source source_len out out_i i budget =
  case (budget <= 0) of
    true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
    _ ->
      case (i >= source_len) of
        true -> FormatNormalizeOk out_i
        _ ->
          let line_end = format_line_end request_handle i source_len
              next_i = case (line_end < source_len) of true -> line_end + 1 _ -> line_end
          in case format_parse_monadic_line request_handle source i line_end of
            ParsedLine MonadicLineNil _ ->
              let out1 = format_copy_segment request_handle OwnershipRewriteLinear source i out out_i (line_end - i)
                  out2 = case (line_end < source_len) of
                    true -> slice_set_u8 request_handle OwnershipRewriteLinear out out1 format_newline_byte
                    _ -> out1
              in case (out2 < 0) of
                true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                _ -> format_normalize_monadic_lines_with_budget request_handle source source_len out out2 next_i (budget - 1)
            ParsedLine (MonadicLineNode _ _ base_indent _ _ _ _) flags ->
              let has_first_lambda = flags == 1 || flags == 3
                  first_lambda = case has_first_lambda of
                    true -> 1
                    _ -> 0
                  has_first_multiline = flags == 2 || flags == 3
                  first_multiline = case has_first_multiline of
                    true -> 1
                    _ -> 0
                  ChainCollect _ chain_end chain_count chain_lambda chain_multiline = format_collect_monadic_chain request_handle source source_len base_indent next_i 1 first_lambda first_multiline
                  normalized_chain_end = case (chain_end > i) of
                    true -> chain_end
                    _ -> next_i
                  should_normalize_chain = chain_count >= 2 && chain_lambda == 1 && chain_multiline == 0
                  is_normalizable_chain_size = chain_count >= 2
                  has_lambda_chain = chain_lambda == 1
                  is_one_line = chain_multiline == 0
              in let normalize_chain_state =
                   case should_normalize_chain is_normalizable_chain_size has_lambda_chain is_one_line of
                     true true true true -> 0
                     _ _ _ _ -> 1
                 in case normalize_chain_state of
                   0 ->
                     let out1 = format_normalize_chain_region request_handle source source_len out out_i i normalized_chain_end base_indent
                     in case out1 of
                       FormatNormalizeError err -> FormatNormalizeError err
                       FormatNormalizeOk out1_i ->
                         case (out1_i < 0) of
                           true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                           _ -> format_normalize_monadic_lines_with_budget request_handle source source_len out out1_i normalized_chain_end (budget - 1)
                   _ ->
                     let copy_len = case (normalized_chain_end > i) of
                           true -> normalized_chain_end - i
                           _ -> next_i - i
                         out1 = format_copy_segment request_handle OwnershipRewriteLinear source i out out_i copy_len
                     in case (out1 < 0) of
                       true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
                       _ -> format_normalize_monadic_lines_with_budget request_handle source source_len out out1 normalized_chain_end (budget - 1)

format_normalize_source request_handle source source_len out out_i =
  let decoded = slice_new_u8 (source_len + 1)
      decoded_len = format_unescape_source_loop request_handle source source_len decoded 0 0
      normalized = slice_new_u8 (decoded_len + format_default_line_width * 8)
      normalized_len = format_normalize_source_lines request_handle OwnershipRewriteLinear decoded decoded_len normalized 0 0
      monadic = slice_new_u8 (normalized_len * 2 + format_default_line_width * 4)
      monadic_len = format_normalize_monadic_lines request_handle normalized normalized_len monadic 0 0
  in case monadic_len of
    FormatNormalizeError err -> FormatNormalizeError err
    FormatNormalizeOk monadic_len_i ->
      case (monadic_len_i < 0) of
        true -> FormatNormalizeError FormatNonProgressNormalizeMonadicLines
        _ -> FormatNormalizeOk (format_copy_segment request_handle OwnershipRewriteLinear monadic 0 out out_i monadic_len_i)

find_source_start request_handle i req_len =
  scan_find_json_key_value_start request_handle i req_len "\"source\""

format_nonprogress_guard_limit = 1024
format_long_line_scan_limit = 512

format_nonprogress_error_message error =
  case error of
    FormatNonProgressChainRegion -> "format non-progress recursion in format_normalize_chain_region"
    FormatNonProgressCopyChainBody -> "format non-progress recursion in format_copy_chain_body"
    FormatNonProgressNormalizeMonadicLines -> "format non-progress recursion in format_normalize_monadic_lines"
    _ -> "format non-progress recursion detected in monadic formatter"


format_empty_response request_handle ownership_mode =
  json_response_with_literal_prefix_suffix request_handle ownership_mode json_format_prefix json_format_suffix

format_source_response request_handle ownership_mode source_start req_len =
  let source_end = json_slice_end request_handle source_start req_len
      source_len = source_end - source_start
      formatted = slice_new_u8 (source_len * 2 + format_default_line_width * 8)
      format_result = format_normalize_source request_handle source_start source_len formatted 0
  in case format_result of
    FormatNormalizeError err ->
      error_response_from_message request_handle ownership_mode (format_nonprogress_error_message err)
    FormatNormalizeOk formatted_len ->
      json_response_with_escaped_slice_segment
        request_handle
        ownership_mode
        json_format_prefix
        json_format_suffix
        formatted
        0
        formatted_len

format_ok_response request_handle ownership_mode =
  let req_len = slice_len request_handle
      source_start = find_source_start request_handle 0 req_len
  in case (source_start == req_len) of
    true -> format_empty_response request_handle ownership_mode
    _ -> format_source_response request_handle ownership_mode source_start req_len
