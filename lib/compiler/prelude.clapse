module compiler.prelude
export id, compose, map_replace_default, ap_default, then_m_default, keep_left_default, keep_right_default, alt_default, map_replace, then_m, keep_left, keep_right, alt, Unit, Lazy, force, lazy, not, and, or, xor, implies, byte, char, Boolean, Functor, Applicative, Monad, Alternative

infixl 1 >>=
infixl 1 >>
infixl 3 <|>
infixl 4 <$
infixl 4 <$>
infixl 4 <*>
infixl 4 <*
infixl 4 *>

id x = x
compose f g x = f (g x)
map_replace_default x fa = fmap (\_ -> x) fa
ap_default mf mx = bind mf (\f -> bind mx (\x -> pure (f x)))
then_m_default m n = bind m (\_ -> n)
keep_left_default u v = ap (fmap (\x -> (\_ -> x)) u) v
keep_right_default u v = ap (fmap (\_ -> id) u) v
alt_default a b = append a b
map_replace x fa = map_replace_default x fa

class Functor f where
  fmap : (a -> b) -> f a -> f b
  <$> : (a -> b) -> f a -> f b
  <$ : a -> f b -> f a
  <$> = fmap
  <$ = map_replace
law Functor identity = fmap id x => x
law Functor composition = fmap f (fmap g x) => fmap (compose f g) x
law Functor map_replace_default = map_replace x fx => map_replace_default x fx

class Applicative f where
  pure : a -> f a
  ap : f (a -> b) -> f a -> f b
  <*> : f (a -> b) -> f a -> f b
  keep_left : f a -> f b -> f a
  keep_right : f a -> f b -> f b
  <* : f a -> f b -> f a
  *> : f a -> f b -> f b
  <*> = ap
  <* = keep_left
  *> = keep_right
law Applicative identity = ap (pure id) x => x
law Applicative homomorphism = ap (pure f) (pure x) => pure (f x)
law Applicative interchange = ap u (pure y) => ap (pure (\f -> f y)) u
law Applicative composition = ap (ap (ap (pure compose) u) v) w => ap u (ap v w)
law Applicative keep_left_default = keep_left u v => keep_left_default u v
law Applicative keep_right_default = keep_right u v => keep_right_default u v

class Monad m where
  bind : m a -> (a -> m b) -> m b
  then_m : m a -> m b -> m b
  >>= : m a -> (a -> m b) -> m b
  >> : m a -> m b -> m b
  >>= = bind
  >> = then_m
law Monad left_identity = bind (pure x) f => f x
law Monad right_identity = bind m pure => m
law Monad associativity = bind (bind m f) g => bind m (\x -> bind (f x) g)
law Monad then_default = then_m m n => then_m_default m n

data ByteIntent
data CharIntent
data Unit = Unit

data Lazy a = Lazy : (Unit -> a) -> Lazy a

force l =
  case l of
    Lazy thunk -> thunk Unit

lazy thunk = Lazy thunk

class AsByte a where
  as_byte : ByteIntent -> a -> a

class AsChar a where
  as_char : CharIntent -> a -> a

byte x = as_byte ByteIntent x
char x = as_char CharIntent x

instance AsByte i64 where
  as_byte _ x = x

instance AsChar i64 where
  as_char _ x = x

class Alternative f where
  empty : f a
  append : f a -> f a -> f a
  alt : f a -> f a -> f a
  <|> : f a -> f a -> f a
  <|> = alt
law Alternative left_identity = append empty x => x
law Alternative right_identity = append x empty => x
law Alternative associativity = append (append x y) z => append x (append y z)
law Alternative alt_default = alt x y => alt_default x y

data bool = true<1> | false<0>

infixr 3 &&
infixr 2 ||

class Boolean b where
  not : b -> b
  and : b -> b -> b
  or : b -> b -> b
  xor : b -> b -> b
  implies : b -> b -> b
  && : b -> b -> b
  || : b -> b -> b
  && = and
  || = or
  xor a b = or (and a (not b)) (and (not a) b)
  implies a b = or (not a) b
law Boolean and_identity = and true x => x
law Boolean and_annihilation = and false x => false
law Boolean or_identity = or x false => x
law Boolean or_annihilation = or x true => true
law Boolean double_negation = not (not x) => x

instance Boolean bool where
  not true = false
  not false = true

  and false _ = false
  and _ false = false
  and _ _ = true

  or true _ = true
  or _ true = true
  or _ _ = false

  xor true false = true
  xor false true = true
  xor _ _ = false

  implies true false = false
  implies _ _ = true

  && false _ = false
  && _ false = false
  && _ _ = true

  || true _ = true
  || _ true = true
  || _ _ = false
