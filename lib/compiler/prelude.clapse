module compiler.prelude
export id, compose, then_m, keep_left, keep_right, alt, bool_not, bool_and, bool_or, not, and, or, Functor, Applicative, Monad, Alternative, Boolean

infixl 1 >>= = bind
infixl 1 >> = then_m
infixl 3 <|> = alt
infixl 4 <$> = fmap
infixl 4 <*> = ap
infixl 4 <* = keep_left
infixl 4 *> = keep_right

id x = x
compose f g x = f (g x)
ap mf mx = bind mf (\f -> bind mx (\x -> pure (f x)))
then_m m n = bind m (\_ -> n)
keep_left u v = ap (fmap (\x -> (\_ -> x)) u) v
keep_right u v = ap (fmap (\_ -> id) u) v
alt a b = append a b

class Functor f where
  fmap : (a -> b) -> f a -> f b
law Functor identity = fmap id x => x
law Functor composition = fmap f (fmap g x) => fmap (compose f g) x

class Applicative f where
  pure : a -> f a
  ap : f (a -> b) -> f a -> f b
  keep_left : f a -> f b -> f a
  keep_right : f a -> f b -> f b
law Applicative identity = ap (pure id) x => x
law Applicative homomorphism = ap (pure f) (pure x) => pure (f x)
law Applicative interchange = ap u (pure y) => ap (pure (\f -> f y)) u
law Applicative composition = ap (ap (ap (pure compose) u) v) w => ap u (ap v w)
law Applicative keep_left_default = keep_left u v => ap (fmap (\x -> (\_ -> x)) u) v
law Applicative keep_right_default = keep_right u v => ap (fmap (\_ -> id) u) v

class Monad m where
  bind : m a -> (a -> m b) -> m b
  then_m : m a -> m b -> m b
law Monad left_identity = bind (pure x) f => f x
law Monad right_identity = bind m pure => m
law Monad associativity = bind (bind m f) g => bind m (\x -> bind (f x) g)
law Monad then_default = then_m m n => bind m (\_ -> n)

class Alternative f where
  empty : f a
  append : f a -> f a -> f a
  alt : f a -> f a -> f a
law Alternative left_identity = append empty x => x
law Alternative right_identity = append x empty => x
law Alternative associativity = append (append x y) z => append x (append y z)
law Alternative alt_default = alt x y => append x y

data bool = true<1> | false<0>

infixr 3 && = and
infixr 2 || = or

bool_not b = case b of
  true -> false
  false -> true

bool_and a b = case a b of
  true true -> true
  _ _ -> false

bool_or a b = case a b of
  false false -> false
  _ _ -> true

not = bool_not
and = bool_and
or = bool_or

class Boolean b where
  not : b -> b
  and : b -> b -> b
  or : b -> b -> b
law Boolean and_identity = and true x => x
law Boolean and_annihilation = and false x => false
law Boolean or_identity = or x false => x
law Boolean or_annihilation = or x true => true
law Boolean double_negation = not (not x) => x

instance BooleanBool : Boolean bool where
  not = bool_not
  and = bool_and
  or = bool_or
