module compiler.prelude
export id, compose, then_m, keep_left, keep_right, alt, bool_not, bool_and, bool_or, not, and, or, Boolean

infixl 1 >>= = bind
infixl 1 >> = then_m
infixl 3 <|> = alt
infixl 4 <$> = fmap
infixl 4 <*> = ap
infixl 4 <* = keep_left
infixl 4 *> = keep_right

id x = x
compose f g x = f (g x)
then_m m n = bind m (\_ -> n)
keep_left u v = ap (fmap (\x -> (\_ -> x)) u) v
keep_right u v = ap (fmap (\_ -> id) u) v
alt a b = append a b

class Functor f : functor
law Functor identity = fmap id x => x
law Functor composition = fmap f (fmap g x) => fmap (compose f g) x

class Applicative f : applicative
law Applicative identity = ap (pure id) x => x
law Applicative homomorphism = ap (pure f) (pure x) => pure (f x)
law Applicative interchange = ap u (pure y) => ap (pure (\f -> f y)) u
law Applicative composition = ap (ap (ap (pure compose) u) v) w => ap u (ap v w)

class Monad m : monad
law Monad left_identity = bind (pure x) f => f x
law Monad right_identity = bind m pure => m
law Monad associativity = bind (bind m f) g => bind m (\x -> bind (f x) g)

class Alternative f : monoid
law Alternative left_identity = append empty x => x
law Alternative right_identity = append x empty => x
law Alternative associativity = append (append x y) z => append x (append y z)

data bool = true<1> | false<0>

infixr 3 && = and
infixr 2 || = or

bool_not b = case b of
  true -> false
  false -> true

bool_and a b = case a b of
  true true -> true
  _ _ -> false

bool_or a b = case a b of
  false false -> false
  _ _ -> true

not = bool_not
and = bool_and
or = bool_or

class Boolean b : bool
law Boolean and_identity = and true x => x
law Boolean and_annihilation = and false x => false
law Boolean or_identity = or x false => x
law Boolean or_annihilation = or x true => true
law Boolean double_negation = not (not x) => x

instance BooleanBool : Boolean bool not=not and=and or=or
