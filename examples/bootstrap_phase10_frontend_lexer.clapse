module bootstrap_phase10_frontend_lexer
export main

data bool = true<1> | false<0>

if2 p t f = case p of
  true -> t
  _ -> f

or2 a b = if2 a true b
and2 a b = if2 a b false
not2 a = if2 a false true

is_space b = or2 (b == 32) (or2 (b == 9) (or2 (b == 10) (b == 13)))

is_digit b = and2 (b >= 48) (b <= 57)

is_lower b = and2 (b >= 97) (b <= 122)

is_upper b = and2 (b >= 65) (b <= 90)

is_ident_start b = or2 (is_lower b) (or2 (is_upper b) (b == 95))
is_ident_char b = or2 (is_ident_start b) (or2 (is_digit b) (b == 39))

is_symbol_char b = not2 (or2 (is_space b) (or2 (is_ident_char b) (or2 (is_digit b) (or2 (b == 34) (b == 39)))))

skip_spaces src i len =
  case (i < len) of
    true -> let b = slice_get_u8 src i
            in if2 (is_space b) (skip_spaces src (i + 1) len) i
    _ -> i

find_ident_end src i len =
  case (i < len) of
    true -> let b = slice_get_u8 src i
            in if2 (is_ident_char b) (find_ident_end src (i + 1) len) i
    _ -> i

find_number_end src i len =
  case (i < len) of
    true -> let b = slice_get_u8 src i
            in if2 (is_digit b) (find_number_end src (i + 1) len) i
    _ -> i

find_string_end src i len escaped = case (i < len) of
  false -> i
  _ ->
    let b = slice_get_u8 src i
    in case escaped (b == 92) (b == 34) of
      true _ _ -> find_string_end src (i + 1) len false
      _ true _ -> find_string_end src (i + 1) len true
      _ _ true -> i + 1
      _ _ _ -> find_string_end src (i + 1) len false

find_char_end src i len escaped =
  case (i < len) of
    true -> let b = slice_get_u8 src i
            in case escaped (b == 92) (b == 39) of
                 true _ _ -> find_char_end src (i + 1) len false
                 _ true _ -> find_char_end src (i + 1) len true
                 _ _ true -> i + 1
                 _ _ _ -> find_char_end src (i + 1) len false
    _ -> i

find_symbol_end src i len =
  case (i < len) of
    true -> let b = slice_get_u8 src i
            in if2 (is_symbol_char b) (find_symbol_end src (i + 1) len) i
    _ -> i

copy_range_into src src_i dst dst_i n j =
  if2 (j == n)
    dst
    (let b = slice_get_u8 src (src_i + j)
         next = slice_set_u8 dst (dst_i + j) b
     in copy_range_into src src_i next dst_i n (j + 1))

slice_range src start end =
  let n = end - start
      dst = slice_new_u8 n
  in copy_range_into src start dst 0 n 0

is_keyword_slice w =
  case (slice_to_string w) of
    "module" -> true
    "import" -> true
    "export" -> true
    "data" -> true
    "newtype" -> true
    "class" -> true
    "law" -> true
    "instance" -> true
    "case" -> true
    "of" -> true
    "let" -> true
    "in" -> true
    "infix" -> true
    "infixl" -> true
    "infixr" -> true
    _ -> false

scan_counts_result kw id n str ch sym =
  kw * 100000 + id * 10000 + n * 1000 + str * 100 + ch * 10 + sym

scan_counts_fuel src i len fuel kw id n str ch sym =
  if2 (fuel == 0) (scan_counts_result kw id n str ch sym) (scan_counts_fuel_nonempty src i len (fuel - 1) kw id n str ch sym)

scan_counts_fuel_nonempty src i len fuel kw id n str ch sym =
  if2 (i < len) (scan_counts_fuel_after_skip src (skip_spaces src i len) len fuel kw id n str ch sym) (scan_counts_result kw id n str ch sym)

scan_counts_fuel_after_skip src i0 len fuel kw id n str ch sym =
  if2 (i0 < len) (scan_counts_fuel_token src i0 len fuel kw id n str ch sym) (scan_counts_result kw id n str ch sym)

scan_counts_fuel_token src i0 len fuel kw id n str ch sym =
  let b = slice_get_u8 src i0
      is_ident = is_ident_start b
  in case is_ident of
    true -> scan_counts_fuel_ident src i0 len fuel kw id n str ch sym
    _ ->
      case (is_digit b) of
        true -> let j = find_number_end src i0 len
                in scan_counts_fuel src j len fuel kw id (n + 1) str ch sym
        _ ->
          case (b == 34) of
            true -> let j = find_string_end src (i0 + 1) len false
                    in scan_counts_fuel src j len fuel kw id n (str + 1) ch sym
            _ ->
              case (b == 39) of
                true -> let j = find_char_end src (i0 + 1) len false
                        in scan_counts_fuel src j len fuel kw id n str (ch + 1) sym
                _ ->
                  let j = find_symbol_end src i0 len
                      j2 = if2 (j == i0) (i0 + 1) j
                  in scan_counts_fuel src j2 len fuel kw id n str ch (sym + 1)

scan_counts_fuel_ident src i0 len fuel kw id n str ch sym =
  let j = find_ident_end src i0 len
      w = slice_range src i0 j
  in case (is_keyword_slice w) of
    true -> scan_counts_fuel src j len fuel (kw + 1) id n str ch sym
    _ -> scan_counts_fuel src j len fuel kw (id + 1) n str ch sym

sample_source =
  "module x = 1\n"

lexer_checksum src =
  let s = str_to_slice src
      len = slice_len s
      fuel = len + 1
  in scan_counts_fuel s 0 len fuel 0 0 0 0 0 0

main _ =
  lexer_checksum sample_source
