is_alive_next alive neighbors = case (neighbors == 3) (alive && neighbors == 2) of
  1 _ -> 1
  _ 1 -> 1
  _ _ -> 0

main alive neighbors = is_alive_next alive neighbors

mod a b = a - (a / b) * b
idx w x y = y * w + x
wrap_sub x size = mod (x - 1 + size) size
wrap_add x size = mod (x + 1) size
cell_at cells w x y = slice_get_u8 cells (idx w x y)
alive_neighbors cells w h x y =
  let xl = wrap_sub x w
      xr = wrap_add x w
      yu = wrap_sub y h
      yd = wrap_add y h
  in cell_at cells w xl yu + cell_at cells w x yu + cell_at cells w xr yu + cell_at cells w xl y + cell_at cells w xr y + cell_at cells w xl yd + cell_at cells w x yd + cell_at cells w xr yd
life_next_from_slice cells w h i =
  let x = mod i w
      y = i / w
      alive = cell_at cells w x y
      neighbors = alive_neighbors cells w h x y
  in is_alive_next alive neighbors
step_range_split in_cells out_cells w h start span =
  let half = span / 2
      left_out = step_range in_cells out_cells w h start half
      right_start = start + half
      right_span = span - half
  in step_range in_cells left_out w h right_start right_span
step_range in_cells out_cells w h start span =
  case (span == 0) (span == 1) of
    1 _ -> out_cells
    _ 1 -> slice_set_u8 out_cells start (life_next_from_slice in_cells w h start)
    _ _ -> step_range_split in_cells out_cells w h start span
step_board in_cells out_cells w h =
  let mark = region_mark 0
      result = step_range in_cells out_cells w h 0 (w * h)
      reset_token = region_reset mark
  in result

data LifeState = LifeState current next generation

init_state current next = LifeState current next 0
state_current state = let LifeState current next_ignored generation_ignored = state in current
state_generation state = let LifeState current_ignored next_ignored generation = state in generation
step_state w h state =
  let LifeState current next generation = state
  in let filled = step_board current next w h
         next_generation = generation + 1
     in LifeState filled current next_generation
step_state_n w h n state = case (n == 0) of
  1 -> state
  _ -> step_state_n w h (n - 1) (step_state w h state)

sum_slice cells start span = case (span == 0) (span == 1) of
  1 _ -> 0
  _ 1 -> slice_get_u8 cells start
  _ _ ->
    let half = span / 2
        left_sum = sum_slice cells start half
        right_start = start + half
        right_span = span - half
        right_sum = sum_slice cells right_start right_span
    in left_sum + right_sum
state_alive_count w h state = let current = state_current state in sum_slice current 0 (w * h)
